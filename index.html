<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Genetic Epidemiology — Map + Timeline + Dual District Charts + Genetic Tree</title>
<link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
<style>
  @import url("https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap");
    :root{
    --color-bg:#101526;
    --color-surface:#1B2337;
    --color-surface-alt:#232D45;
    --color-muted:#9DA9C6;
    --color-text:#F4F7FF;
    --color-chip:#223048;
    --color-border:rgba(148,163,184,0.35);
    --color-map-bg:#0D1627;
    --color-focus:rgba(96,165,250,0.85);
    --color-accent:#4DD0E1;
    --color-accent-strong:#1FA2B7;
    --shadow-elevated:0 18px 48px rgba(10,14,34,0.45);
    --radius-lg:18px;
    --radius-md:12px;
    --radius-sm:8px;
    --font-sans:'Inter','Segoe UI',system-ui,-apple-system,sans-serif;
    --tl-h:56px;
    --bg:var(--color-bg);
    --panel:var(--color-surface);
    --muted:var(--color-muted);
    --text:var(--color-text);
    --chip:var(--color-chip);
    --border:var(--color-border);
    --mapbg:var(--color-map-bg);
    --district-fill:#111726;
    --district-stroke:#3C4A66;
    --district-weight:0.3;
    --province-stroke:#91A4BF;
    --province-weight:1;
    --label-badge-bg:rgba(0,0,0,0.3);
    --label-badge-brd:rgba(255,255,255,0.12);
    --label-color:#F4F7FF;
    --fade:0.24;
    --fade-stroke:0.38;
    --table-border:rgba(148,163,184,0.22);
    --accent:var(--color-accent);
    --accent-contrast:#0B1A22;
  }
  html.light{
    --color-bg:#F7F9FF;
    --color-surface:#FFFFFF;
    --color-surface-alt:#F2F5FF;
    --color-muted:#5B647A;
    --color-text:#1B2337;
    --color-chip:#EFF3FB;
    --color-border:rgba(15,23,42,0.12);
    --color-map-bg:#D9E6F2;
    --color-focus:rgba(37,99,235,0.75);
    --color-accent:#2563EB;
    --color-accent-strong:#1D4ED8;
    --bg:var(--color-bg);
    --panel:var(--color-surface);
    --muted:var(--color-muted);
    --text:var(--color-text);
    --chip:var(--color-chip);
    --border:var(--color-border);
    --mapbg:var(--color-map-bg);
    --district-fill:#FFFFFF;
    --district-stroke:#D0D7E6;
    --district-weight:0.3;
    --province-stroke:#99A7BF;
    --province-weight:1;
    --label-badge-bg:rgba(255,255,255,0.82);
    --label-badge-brd:rgba(71,85,105,0.22);
    --label-color:#1B2337;
    --fade:0.32;
    --fade-stroke:0.46;
    --table-border:rgba(148,163,184,0.24);
    --accent:var(--color-accent);
    --accent-contrast:#FFFFFF;
  }

  html, body {height:100%; margin:0; font-family:var(--font-sans); background:var(--bg); color:var(--text)}
  body{overflow-x:hidden; background:var(--bg); color:var(--text);}
  *:focus-visible{outline:2px solid var(--color-focus); outline-offset:3px;}
  button:focus-visible,input:focus-visible,select:focus-visible{box-shadow:0 0 0 3px rgba(77,208,225,0.28);}

  #layout {display:grid; grid-template-rows: 1fr auto; height:100vh}

  /* Map */
  #mapWrap {position:relative}
  #map {height:100%; width:100%; background:var(--mapbg)}
  .province-label{color:var(--label-color); font-size:12px; font-weight:700; text-shadow:0 1px 0 rgba(0,0,0,.35);}
  .province-label .badge{display:inline-block; padding:2px 6px; border-radius:8px; background:var(--label-badge-bg); border:1px solid var(--label-badge-brd);}
  .count-badge{background:rgba(0,0,0,0.55); color:#fff; border:1px solid rgba(255,255,255,.2); padding:2px 6px; border-radius:999px; font-size:11px; font-weight:700}

  /* Date title (top centered) */
  #dateTitle{
    position:absolute; top:10px; left:50%; transform:translateX(-50%);
    z-index:550; font-size:22px; font-weight:800; letter-spacing:.02em;
    background:var(--color-surface-alt); border:1px solid var(--border);
    padding:8px 18px; border-radius:var(--radius-md); box-shadow:var(--shadow-elevated);
  }

  /* Left controls */
  #leftPanel{
    position:absolute; top:56px; left:12px; z-index:500;
    background:var(--panel); border:1px solid var(--border); border-radius:var(--radius-lg); padding:16px; width:360px;
    box-shadow:var(--shadow-elevated);
    max-height:85vh; overflow:auto;
    padding-bottom: calc(var(--tl-h) + 14px); /* prevent overlap with timeline */
  }
  #leftPanel h2{font-size:13px; margin:0 0 6px 0; opacity:.85; text-transform:uppercase; letter-spacing:.08em}
  .ctrl{display:flex; align-items:center; gap:8px; margin:6px 0; font-size:12px}
  .ctrl label{min-width:170px; color:var(--muted)}
  .ctrl input[type="number"]{width:90px}
  .btn{background:rgba(255,255,255,0.04); border:1px solid var(--border); color:var(--text); border-radius:var(--radius-sm); padding:6px 12px; cursor:pointer; font-size:12px; transition:background-color 120ms ease, border-color 120ms ease, color 120ms ease;}
  .btn:hover{background:rgba(255,255,255,0.08); border-color:rgba(255,255,255,0.2);}
  .btn:disabled{opacity:.55; cursor:not-allowed; background:rgba(255,255,255,0.04);}
  #toast{position:absolute; left:50%; transform:translateX(-50%); top:12px; background:var(--panel); border:1px solid var(--border); color:var(--text); border-radius:var(--radius-md); padding:10px 14px; font-size:12px; display:none; z-index:600; box-shadow:var(--shadow-elevated);}

  /* Right charts + legend (legend under charts) */
  #rightPanel{
    position:absolute; top:56px; right:12px; z-index:700;
    background:var(--panel); border:1px solid var(--border); border-radius:var(--radius-lg); padding:16px; width:440px;
    box-shadow:var(--shadow-elevated);
  }
  #rightPanel h2{font-size:13px; margin:0 0 6px 0; opacity:.85; text-transform:uppercase; letter-spacing:.08em}
  #chartA, #chartB{width:100%; height:220px}
  .chip{display:inline-block; background:var(--chip); border:1px solid var(--border); border-radius:999px; padding:2px 8px; font-size:12px; color:var(--muted)}
  .legend-row{display:flex; align-items:center; gap:8px; margin:4px 0; cursor:pointer; padding:4px 6px; border-radius:var(--radius-sm); transition:background-color 120ms ease, opacity 120ms ease;}
  .legend-row:hover{background:rgba(255,255,255,0.06);}
  .legend-row.inactive{opacity:.45}
  .swatch{
  width:16px; height:16px;
  display:inline-flex; align-items:center; justify-content:center;
  border:none; padding:0; background:none;
}
  .legend-actions{display:flex; gap:6px; margin:6px 0}
  .legend-actions button{font-size:12px; padding:3px 6px; border:1px solid var(--border); background:transparent; color:var(--text); border-radius:6px; cursor:pointer}
  .panel-header{display:flex; align-items:center; justify-content:space-between; gap:8px;}
  .panel-header h2{margin:0;}
  .panel-hide-btn{padding:4px 8px; font-size:11px; border-radius:999px;}
  .panel-toggle-button{position:absolute; top:16px; z-index:750; background:var(--color-surface-alt); border:1px solid var(--border); color:var(--text); border-radius:var(--radius-md); padding:6px 12px; font-size:11px; cursor:pointer; box-shadow:var(--shadow-elevated); transition:background-color 120ms ease, border-color 120ms ease; display:inline-flex; align-items:center; gap:6px;}
  .panel-toggle-button:hover{background:var(--panel);}
  .panel-toggle-button:focus-visible{outline:2px solid var(--accent); outline-offset:2px;}
  #showLeftPanelBtn{left:16px;}
  #showRightPanelBtn{right:16px;}
  #leftPanel, #rightPanel{transition:transform .25s ease, opacity .25s ease;}
  #leftPanel.is-hidden{transform:translateX(-120%); opacity:0; pointer-events:none;}
  #rightPanel.is-hidden{transform:translateX(120%); opacity:0; pointer-events:none;}


  select, input, button{font:inherit}

  /* Bottom timeline */
#timelineBar{
  position:absolute; bottom:0; left:0; right:0;
  height: var(--tl-h);
  display:grid; grid-template-columns: 1fr auto; gap:12px; align-items:center;
  padding:8px 12px; background:var(--panel); color:var(--text); border-top:1px solid var(--border);
  z-index:600;
}
  #timeSlider{width:100%}
  .pill{background:var(--chip); border:1px solid var(--border); color:var(--muted); padding:4px 8px; border-radius:999px; font-size:12px}

  /* Genetic tree panel */
  #treePanel { margin-top:10px; padding-top:8px; border-top:1px solid var(--border); }
  #treePanel h2{font-size:13px; margin:0 0 6px 0; opacity:.85; text-transform:uppercase; letter-spacing:.08em}
  #treeSVG{width:100%; height:300px; overflow:visible; display:block; cursor:grab; user-select:none; touch-action:none} /* ? ensure tips/labels are visible */
  #treeLegend{margin-top:6px; font-size:12px}
  /* Collapsible table */
  details#simDetails{margin-top:8px; border-top:1px dashed var(--border); padding-top:8px}
  #simTable{width:100%; border-collapse:collapse; font-size:12px; margin-top:6px}
  #simTable th,#simTable td{border:1px solid var(--table-border); padding:4px 6px; text-align:left}
  #simTable th{background:rgba(255,255,255,.06); color:var(--text)}
  
  /* Sticky player buttons inside the left panel, always above the timeline */
.panel-actions{
  position: sticky;
  bottom: calc(var(--tl-h) + 8px);
  z-index: 650;                 /* above the map & within the panel */
  background: var(--panel);
  border-top: 1px solid var(--border);
  padding-top: 6px;
}

</style>
</head>
<body>
<div id="layout">
  <div id="mapWrap">
    <div id="map"></div>
    <div id="dateTitle">--</div>
    <button id="showLeftPanelBtn" class="panel-toggle-button btn" type="button" hidden>Show controls</button>
    <button id="showRightPanelBtn" class="panel-toggle-button btn" type="button" hidden>Show charts</button>

    <!-- Left control panel -->
    <aside id="leftPanel" aria-label="Controls">
      <div class="panel-header">
        <h2>Data & Controls</h2>
        <button id="hideLeftPanelBtn" class="btn panel-hide-btn" type="button">Hide controls</button>
      </div>
      <div class="ctrl"><label>Districts GeoJSON (ADM2)</label><input id="geojsonDistrictsFile" type="file" accept=".geojson,.json,application/geo+json" /></div>
      <div class="ctrl"><label>Provinces GeoJSON (ADM1)</label><input id="geojsonProvincesFile" type="file" accept=".geojson,.json,application/geo+json" /></div>
      <div class="ctrl"><label>Samples CSV</label><input id="csvFile" type="file" accept=".csv" /></div>

      <div class="ctrl"><label>Days / step</label><input id="speedDays" type="number" min="1" value="7" /></div>
      <div class="ctrl"><label>Step (ms)</label><input id="stepInterval" type="number" min="100" step="100" value="600" /></div>
      <div class="ctrl"><label>Window (days)</label><input id="windowDays" type="number" min="1" value="30" /></div>
      <div class="ctrl"><label>Lifespan (days)</label><input id="lifespanDays" type="number" min="1" value="180" /></div>
      <div class="ctrl"><label>Marker size (px)</label><input id="markerSize" type="number" min="3" max="18" value="8" /></div>
      <div class="ctrl"><label>Jitter within (m)</label><input id="jitterM" type="number" min="0" step="25" value="5000" /></div>
      <div class="ctrl"><label>Show sample counts</label><input id="toggleCounts" type="checkbox" checked /></div>
      <div class="ctrl"><label>Province labels</label><input id="toggleProvLabels" type="checkbox" checked /></div>
      <div class="ctrl">
        <label>Theme</label>
        <select id="themeSelect" style="flex:1">
          <option value="dark">Dark</option>
          <option value="light" selected>Light</option>
        </select>
      </div>

      <!-- Genetic distances -->
<div id="treePanel">
  <h2>Genetic Similarity Tree</h2>
  <div class="ctrl">
    <label>Genetic distance (.tab)</label>
    <input id="tabFile" type="file" accept=".tab,.tsv,text/tab-separated-values,text/plain" />
  </div>

  <!-- Toggle button -->
  <div class="ctrl" style="margin-top:6px">
    <button id="treeToggle" class="btn">Show genetic tree</button>
  </div>

  <!-- Tree body (hidden by default) -->
  <div id="treeBody" style="display:none">
  <div class="ctrl" id="treeZoomCtrl" style="gap:6px; margin:4px 0 6px 0">
  <button id="treeZoomIn" class="btn" title="Zoom in">+</button>
  <button id="treeZoomOut" class="btn" title="Zoom out">-</button>
</div>
    <svg id="treeSVG"></svg>
    <div id="treeNote" style="font-size:12px; color:var(--muted); margin-top:6px"></div>
    <div id="treeLegend" style="margin-top:6px; font-size:12px"></div>
  </div>
</div>


        <!-- Collapsible similarity table -->
        <details id="simDetails">
          <summary style="cursor:pointer">Genetic similarity table (toggle)</summary>
          <div id="simTableWrap"></div>
        </details>
      </div>

      <div id="playerActions" class="panel-actions ctrl" style="gap:6px; margin-top:8px">
  <button class="btn" id="playBtn"><span aria-hidden="true">&#9654;</span> Play</button>
  <button class="btn" id="pauseBtn"><span aria-hidden="true">&#10073;&#10073;</span> Pause</button>
  <button class="btn" id="resetBtn"><span aria-hidden="true">&#10226;</span> Reset</button>
</div>

      <div class="chip">Space = Play/Pause</div>
    </aside>

    <!-- Right panel: two charts + legend UNDER charts + align axis -->
    <aside id="rightPanel" aria-label="District charts">
      <div class="panel-header">
        <h2>District Trends (stacked by cluster)</h2>
        <button id="hideRightPanelBtn" class="btn panel-hide-btn" type="button">Hide charts</button>
      </div>

      <div class="ctrl">
        <label>District A</label>
        <select id="districtSelectA" style="flex:1"></select>
      </div>
      <svg id="chartA"></svg>

      <div class="ctrl" style="margin-top:8px">
        <label>District B</label>
        <select id="districtSelectB" style="flex:1"></select>
      </div>
      <svg id="chartB"></svg>

      <div class="ctrl" style="margin-top:6px">
        <label>Align axis (rolling 36 months)</label>
        <input id="alignAxisToggle" type="checkbox" checked />
      </div>

      <div style="margin-top:6px" class="chip">
        x: month | y: samples (cumulative to current date)
      </div>

      <!-- Legend under charts (click to multi-select) -->
      <div style="display:flex; align-items:center; gap:8px; margin-top:10px">
        <strong style="font-size:12px; opacity:.85">Legend</strong>
        <div class="legend-actions">
          <button id="legendShowAll">Show all</button>
          <button id="legendHideAll">Hide all</button>
          <button id="legendToggleBtn">Hide</button>
        </div>
      </div>
      <div id="legendBox" style="margin-top:6px; line-height:1.4"></div>
    </aside>

    <div id="toast"></div>
  </div>

  <!-- Timeline -->
  <footer id="timelineBar">
      <input id="timeSlider" type="range" min="0" max="100" step="1" value="0" disabled />
      <div style="display:flex; gap:8px; align-items:center">
        <span class="pill">Date: <b id="currentDateLabel">--</b></span>
      </div>
    </footer>
  </div>

<!-- Libs -->
<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
<script src="https://unpkg.com/papaparse@5.4.1/papaparse.min.js"></script>
<script src="https://unpkg.com/@turf/turf@6.5.0/turf.min.js"></script>
<script src="https://unpkg.com/d3@7/dist/d3.min.js"></script>

<script>
/* ==================== State ==================== */

/* ===== Marker shapes + palette (theme-independent) ===== */
// Curated, high-contrast palette (no grey colors)
const PALETTE24 = Array.from(new Set([
  // ColorBrewer Set 1
  "#e41a1c","#377eb8","#4daf4a","#984ea3","#ff7f00",
  "#F0E442","#a65628","#f781bf","#66c2a5", "#e7298a",
  "#E69F00","#56B4E9","#009E73","#9C755F","#E15759",
  "#EDC948","#B07AA1", "#FF9DA7", "#4E79A7", "#fc8d62",
  "#8da0cb", "#a6d854", "#e5c494", "#7570b3"
]));

// Decide which shape a (non-unclustered) cluster uses based on its index
// 1–24: circle, 25–49: square, 50–74: diamond
function clusterShapeByIndex(i){
  if(i < 24) return "circle";
  if(i < 49) return "square";
  return "diamond";
}

// Build an SVG marker icon for Leaflet (DivIcon)
function svgMarkerIcon({shape,color,size=8,fillOpacity=0.7,strokeOpacity=1}) {
  const s = size, w = (size*2)+6, h = (size*2)+6, cx = w/2, cy = h/2;
  let inner = '';
  if(shape === 'circle'){
    inner = `<circle cx="${cx}" cy="${cy}" r="${s}" fill="${color}" fill-opacity="${fillOpacity}" stroke="${color}" stroke-opacity="${strokeOpacity}" stroke-width="2"/>`;
  }else if(shape === 'square'){
    inner = `<rect x="${cx-s}" y="${cy-s}" width="${2*s}" height="${2*s}" fill="${color}" fill-opacity="${fillOpacity}" stroke="${color}" stroke-opacity="${strokeOpacity}" stroke-width="2"/>`;
  }else if(shape === 'diamond'){
    inner = `<rect x="${cx-s}" y="${cy-s}" width="${2*s}" height="${2*s}" transform="rotate(45 ${cx} ${cy})" fill="${color}" fill-opacity="${fillOpacity}" stroke="${color}" stroke-opacity="${strokeOpacity}" stroke-width="2"/>`;
  }else if(shape === 'triangle'){ // upward triangle for Unclustered
    const p1 = `${cx},${cy-s}`;
    const p2 = `${cx-s},${cy+s}`;
    const p3 = `${cx+s},${cy+s}`;
    inner = `<polygon points="${p1} ${p2} ${p3}" fill="${color}" fill-opacity="${fillOpacity}" stroke="${color}" stroke-opacity="${strokeOpacity}" stroke-width="2"/>`;
  }
  const svg = `<svg xmlns="http://www.w3.org/2000/svg" width="${w}" height="${h}">${inner}</svg>`;
  return L.divIcon({className:'', html: svg, iconSize:[w,h], iconAnchor:[cx,cy]});
}

// Sorted cluster list used for shape bucketing (populated after CSV load)

/* Small SVG used in the legend swatch (global so buildLegend can call it) */
function svgLegendSwatch(shape, color){
  const r = 7; // size of legend marker
  const w = 16, h = 16;
  if (shape === 'circle'){
    return `<svg width="${w}" height="${h}" xmlns="http://www.w3.org/2000/svg">
      <circle cx="${w/2}" cy="${h/2}" r="${r-1}" fill="${color}" stroke="${color}" stroke-width="1.5"/>
    </svg>`;
  } else if (shape === 'square'){
    const s = 2*(r-1);
    const x = (w - s)/2, y = (h - s)/2;
    return `<svg width="${w}" height="${h}" xmlns="http://www.w3.org/2000/svg">
      <rect x="${x}" y="${y}" width="${s}" height="${s}" rx="2" ry="2"
        fill="${color}" stroke="${color}" stroke-width="1.5"/>
    </svg>`;
  } else if (shape === 'diamond'){
    return `<svg width="${w}" height="${h}" xmlns="http://www.w3.org/2000/svg">
      <polygon points="${w/2},2 ${w-2},${h/2} ${w/2},${h-2} 2,${h/2}"
        fill="${color}" stroke="${color}" stroke-width="1.5"/>
    </svg>`;
  } else { // triangle
    return `<svg width="${w}" height="${h}" xmlns="http://www.w3.org/2000/svg">
      <polygon points="${w/2},2 ${w-2},${h-2} 2,${h-2}"
        fill="${color}" stroke="${color}" stroke-width="1.5"/>
    </svg>`;
  }
}

const DAY_MS = 86400000;

const appState = {
  theme: 'light',
  data: {
    samples: [],
    clusters: new Set(),
    clusterOrder: [],
    colorScale: null
  },
  geo: {
    gidToCentroid: new Map(),
    gidToName: new Map(),
    gidToFeature: new Map(),
    districtsLayer: null,
    provincesLayer: null
  },
  map: {
    instance: null,
    markersLayer: null,
    countsLayer: null,
    provinceLabelsLayer: null,
    showCounts: true,
    markerRadius: 8,
    jitterMeters: 5000
  },
  timeline: {
    playing: false,
    timer: null,
    minDay: null,
    maxDay: null,
    currentDay: null,
    stepDays: 7,
    stepIntervalMs: 600,
    windowDays: 30,
    lifespanDays: 180
  },
  legend: {
    selected: new Set()
  },
  tree: {
    zoom: null,
    zoomTransform: d3.zoomIdentity,
    data: null
  },
  compare: {
    mode: 'adm1',
    pinned: []
  }
};

const dataState = appState.data;
const geoState = appState.geo;
const mapState = appState.map;
const timelineState = appState.timeline;
const legendState = appState.legend;
const treeState = appState.tree;
const compareState = appState.compare;

const UNCLUSTERED_CLUSTER = { color: '#8a8f98', shape: 'triangle' };

function getClusterGlyph(clusterName){
  if(!clusterName || clusterName === 'Unclustered'){
    return UNCLUSTERED_CLUSTER;
  }
  const idx = Math.max(0, dataState.clusterOrder.indexOf(clusterName));
  const scale = dataState.colorScale;
  const color = scale ? scale(clusterName) : PALETTE24[idx % PALETTE24.length];
  return { color, shape: clusterShapeByIndex(idx) };
}

/* ==================== Elements ==================== */
const dateTitle         = document.getElementById('dateTitle');
const geojsonDistrictsInput = document.getElementById('geojsonDistrictsFile');
const geojsonProvincesInput = document.getElementById('geojsonProvincesFile');
const csvInput     = document.getElementById('csvFile');
const tabInput     = document.getElementById('tabFile');
const playBtn      = document.getElementById('playBtn');
const pauseBtn     = document.getElementById('pauseBtn');
const resetBtn     = document.getElementById('resetBtn');
const toggleCounts = document.getElementById('toggleCounts');
const speedDaysInput    = document.getElementById('speedDays');
const stepIntervalInput = document.getElementById('stepInterval');
const windowDaysInput   = document.getElementById('windowDays');
const lifespanDaysInput = document.getElementById('lifespanDays');
const markerSizeInput   = document.getElementById('markerSize');
const jitterMInput      = document.getElementById('jitterM');
const timeSlider        = document.getElementById('timeSlider');
const currentDateLabel  = document.getElementById('currentDateLabel');
const districtSelectA   = document.getElementById('districtSelectA');
const districtSelectB   = document.getElementById('districtSelectB');
const themeSelect       = document.getElementById('themeSelect');
const alignAxisToggle   = document.getElementById('alignAxisToggle');
const leftPanelEl      = document.getElementById('leftPanel');
const rightPanelEl     = document.getElementById('rightPanel');
const hideLeftPanelBtn  = document.getElementById('hideLeftPanelBtn');
const hideRightPanelBtn = document.getElementById('hideRightPanelBtn');
const showLeftPanelBtn  = document.getElementById('showLeftPanelBtn');
const showRightPanelBtn = document.getElementById('showRightPanelBtn');
const toggleProvLabels  = document.getElementById('toggleProvLabels');
/* Legend */
const legendBox         = document.getElementById('legendBox');
const legendShowAllBtn  = document.getElementById('legendShowAll');
const legendHideAllBtn  = document.getElementById('legendHideAll');
const legendToggleBtn   = document.getElementById('legendToggleBtn');
const toast             = document.getElementById('toast');
const treeNote          = document.getElementById('treeNote');
const treeZoomIn  = document.getElementById('treeZoomIn');
const treeZoomOut = document.getElementById('treeZoomOut');
const treeToggle        = document.getElementById('treeToggle');
const treeBody          = document.getElementById('treeBody');


/* ==================== UI Helpers ==================== */
function showToast(msg, ms=2800){
  toast.textContent = msg;
  toast.style.display='block';
  clearTimeout(showToast._t);
  showToast._t = setTimeout(()=>toast.style.display='none', ms);
}

/* ==================== Map ==================== */
function initMap(){
  mapState.instance = L.map('map', { zoomControl:false });
  L.control.zoom({ position: 'bottomright' }).addTo(mapState.instance);
  mapState.instance.setView([15,100], 5);
  mapState.markersLayer = L.layerGroup().addTo(mapState.instance);
  mapState.countsLayer  = L.layerGroup().addTo(mapState.instance);
  mapState.provinceLabelsLayer = L.layerGroup().addTo(mapState.instance);
}
initMap();

/* ==================== Theme ==================== */
function applyTheme(theme){
  appState.theme = theme;
  if(theme === 'light'){
    document.documentElement.classList.add('light');
  }else{
    document.documentElement.classList.remove('light');
  }
  const cs = getComputedStyle(document.documentElement);
  if(geoState.districtsLayer){
    geoState.districtsLayer.setStyle({
      color: cs.getPropertyValue('--district-stroke').trim(),
      weight: parseFloat(cs.getPropertyValue('--district-weight')),
      fillColor: cs.getPropertyValue('--district-fill').trim(),
      fillOpacity: 1
    });
  }
  if(geoState.provincesLayer){
    geoState.provincesLayer.setStyle({
      color: cs.getPropertyValue('--province-stroke').trim(),
      weight: parseFloat(cs.getPropertyValue('--province-weight')),
      fillOpacity: 0
    });
  }
}
themeSelect.addEventListener('change', ()=> applyTheme(themeSelect.value));
applyTheme('light');

/* Province labels toggle */
toggleProvLabels.addEventListener('change', ()=>{
  if(toggleProvLabels.checked){
    if(!mapState.instance.hasLayer(mapState.provinceLabelsLayer)) mapState.provinceLabelsLayer.addTo(mapState.instance);
  }else{
    if(mapState.instance.hasLayer(mapState.provinceLabelsLayer)) mapState.instance.removeLayer(mapState.provinceLabelsLayer);
  }
});



/* Panel toggle handlers */
function setLeftPanelVisible(show){
  if(!leftPanelEl || !showLeftPanelBtn || !hideLeftPanelBtn) return;
  const visible = !!show;
  leftPanelEl.classList.toggle('is-hidden', !visible);
  leftPanelEl.setAttribute('aria-hidden', visible ? 'false' : 'true');
  showLeftPanelBtn.hidden = visible;
  showLeftPanelBtn.style.display = visible ? 'none' : 'inline-flex';
  showLeftPanelBtn.setAttribute('aria-expanded', visible ? 'true' : 'false');
  showLeftPanelBtn.setAttribute('aria-hidden', visible ? 'true' : 'false');
  hideLeftPanelBtn.hidden = !visible;
  hideLeftPanelBtn.style.display = visible ? '' : 'none';
}
function setRightPanelVisible(show){
  if(!rightPanelEl || !showRightPanelBtn || !hideRightPanelBtn) return;
  const visible = !!show;
  rightPanelEl.classList.toggle('is-hidden', !visible);
  rightPanelEl.setAttribute('aria-hidden', visible ? 'false' : 'true');
  showRightPanelBtn.hidden = visible;
  showRightPanelBtn.style.display = visible ? 'none' : 'inline-flex';
  showRightPanelBtn.setAttribute('aria-expanded', visible ? 'true' : 'false');
  showRightPanelBtn.setAttribute('aria-hidden', visible ? 'true' : 'false');
  hideRightPanelBtn.hidden = !visible;
  hideRightPanelBtn.style.display = visible ? '' : 'none';
}
function focusWithoutScroll(el){
  if(!el || typeof el.focus !== 'function') return;
  try { el.focus({ preventScroll:true }); }
  catch(_) { el.focus(); }
}
hideLeftPanelBtn.addEventListener('click', ()=>{
  setLeftPanelVisible(false);
  focusWithoutScroll(showLeftPanelBtn);
});
showLeftPanelBtn.addEventListener('click', ()=>{
  setLeftPanelVisible(true);
  focusWithoutScroll(hideLeftPanelBtn);
});
hideRightPanelBtn.addEventListener('click', ()=>{
  setRightPanelVisible(false);
  focusWithoutScroll(showRightPanelBtn);
});
showRightPanelBtn.addEventListener('click', ()=>{
  setRightPanelVisible(true);
  focusWithoutScroll(hideRightPanelBtn);
});
setLeftPanelVisible(true);
setRightPanelVisible(true);

/* ==================== Geo helpers ==================== */
function normalizeKey(x){ return (x==null ? '' : String(x)).trim(); }
function findGidKey(props){
  const keys = Object.keys(props||{});
  const candidates = ['GID_2','GID_1','GID','ADM2_PCODE','ADM1_PCODE','PCODE'];
  for(const c of candidates){ if(keys.includes(c)) return c; }
  for(const k of keys){ if(/GID|PCODE/i.test(k)) return k; }
  return null;
}
function findNameKey(props){
  const keys = Object.keys(props||{});
  const candidates = ['AdmDiv2','AdminDiv2','NAME_2','NAME_1','ADM2_EN','ADM1_EN','NAME','District','district'];
  for(const c of candidates){ if(keys.includes(c)) return c; }
  for(const k of keys){ if(/NAME|DIST|AdmDiv2|AdminDiv2/i.test(k)) return k; }
  return null;
}
function parseDateFlexible(s){
  if(!s) return null;
  const t = Date.parse(s);
  if(!isNaN(t)) return new Date(t);
  const m = String(s).trim().match(/^(\d{1,2})[\/-](\d{1,2})[\/-](\d{2,4})$/);
  if(m){
    const d = +m[1], mo = +m[2]-1, y = m[3].length===2 ? +( '20'+m[3] ) : +m[3];
    return new Date(Date.UTC(y,mo,d));
  }
  return null;
}
function fmtDateFromDayInt(dayInt){
  const dt = new Date(dayInt * DAY_MS);
  const y = dt.getFullYear(), m = String(dt.getMonth()+1).padStart(2,'0'), d = String(dt.getDate()).padStart(2,'0');
  return `${y}-${m}-${d}`;
}

/* Random point inside district with bias near base point */
function cloneLatLngPair(src){
  if(!src) return null;
  if(Array.isArray(src) && src.length >= 2){
    const a = Number(src[0]);
    const b = Number(src[1]);
    if(!isNaN(a) && !isNaN(b)) return [a, b];
  }
  if(typeof src === 'object'){
    if(typeof src.lat === 'number' && typeof src.lng === 'number'){
      return [src.lat, src.lng];
    }
    if(typeof src.latitude === 'number' && typeof src.longitude === 'number'){
      return [src.latitude, src.longitude];
    }
    if(typeof src[0] === 'number' && typeof src[1] === 'number'){
      const a = Number(src[0]);
      const b = Number(src[1]);
      if(!isNaN(a) && !isNaN(b)) return [a, b];
    }
  }
  return null;
}

function randomPointInPolygon(polygon){
  let pt; const bbox = turf.bbox(polygon);
  do { pt = turf.randomPoint(1, { bbox }).features[0]; }
  while (!turf.booleanPointInPolygon(pt, polygon));
  return pt.geometry.coordinates; // [lon, lat]
}

function randomOffsetMeters(baseLatLng, meters){
  const base = cloneLatLngPair(baseLatLng);
  if(!base || !isFinite(meters) || meters <= 0){
    return base;
  }
  const earthRadius = 6371000; // meters
  const distance = Math.random() * meters;
  const bearing = Math.random() * Math.PI * 2;
  const latRad = base[0] * Math.PI / 180;
  const lonRad = base[1] * Math.PI / 180;
  const angDist = distance / earthRadius;
  const sinLat = Math.sin(latRad);
  const cosLat = Math.cos(latRad);
  const sinAng = Math.sin(angDist);
  const cosAng = Math.cos(angDist);
  const newLatRad = Math.asin(sinLat * cosAng + cosLat * sinAng * Math.cos(bearing));
  const newLonRad = lonRad + Math.atan2(Math.sin(bearing) * sinAng * cosLat, cosAng - sinLat * Math.sin(newLatRad));
  return [
    newLatRad * 180 / Math.PI,
    ((newLonRad * 180 / Math.PI + 540) % 360) - 180
  ];
}

function pointNearBaseInPolygon(polygon, baseLatLng, meters){
  const base = cloneLatLngPair(baseLatLng);
  if(!base){
    return randomPointInPolygon(polygon);
  }
  for(let i=0;i<80;i++){
    const candLatLng = randomOffsetMeters(base, meters);
    if(!candLatLng){ break; }
    if(!polygon){ return [candLatLng[1], candLatLng[0]]; }
    const cand = turf.point([candLatLng[1], candLatLng[0]]);
    if(turf.booleanPointInPolygon(cand, polygon)){
      return [candLatLng[1], candLatLng[0]];
    }
  }
  const baseLonLat = [base[1], base[0]];
  if(!polygon){
    return baseLonLat;
  }
  if(turf.booleanPointInPolygon(turf.point(baseLonLat), polygon)) return baseLonLat;
  return randomPointInPolygon(polygon);
}

function jitterWithinDistrict(gid, baseLatLng){
  const feature = geoState.gidToFeature.get(gid);
  const base = cloneLatLngPair(baseLatLng);
  if(!feature){
    return base || null;
  }
  if(base && (!isFinite(mapState.jitterMeters) || mapState.jitterMeters <= 0)){
    return [base[0], base[1]];
  }
  if(isFinite(mapState.jitterMeters) && mapState.jitterMeters>0 && base){
    const coords = pointNearBaseInPolygon(feature, base, mapState.jitterMeters);
    return [coords[1], coords[0]];
  }
  const coordsFallback = randomPointInPolygon(feature);
  return [coordsFallback[1], coordsFallback[0]];
}

/* ==================== Config synced from inputs ==================== */

/* ==================== Loaders ==================== */
// Districts (ADM2)
geojsonDistrictsInput.addEventListener('change', async (e)=>{
  const file = e.target.files[0]; if(!file) return;
  const text = await file.text();
  let gj;
  try { gj = JSON.parse(text); } catch(err){ showToast('Invalid Districts GeoJSON'); return; }

  if(geoState.districtsLayer){ mapState.instance.removeLayer(geoState.districtsLayer); }
  geoState.gidToCentroid.clear(); geoState.gidToName.clear(); geoState.gidToFeature.clear();

  const cs = getComputedStyle(document.documentElement);
  geoState.districtsLayer = L.geoJSON(gj, {
    style: ()=>({
      color: cs.getPropertyValue('--district-stroke').trim(),
      weight: parseFloat(cs.getPropertyValue('--district-weight')),
      fillColor: cs.getPropertyValue('--district-fill').trim(),
      fillOpacity:1
    })
  }).addTo(mapState.instance);

  try { mapState.instance.fitBounds(geoState.districtsLayer.getBounds(), {padding:[20,20]}); } catch(_) {}

  const proto = (gj.features && gj.features[0] && gj.features[0].properties) || {};
  const gidKey  = findGidKey(proto);
  const nameKey = findNameKey(proto);
  if(!gidKey){ showToast('?? Could not find a GID-like property in Districts GeoJSON.'); }

  gj.features.forEach(f=>{
    const gid = normalizeKey(f.properties[gidKey]);
    const nm  = nameKey ? normalizeKey(f.properties[nameKey]) : gid;
    geoState.gidToFeature.set(gid, f);
    let center;
    try { center = turf.center(f).geometry.coordinates; }
    catch(_) { try { center = turf.centroid(f).geometry.coordinates; } catch(err){ center = null; } }
    if(center){
      const latlng = [center[1], center[0]];
      geoState.gidToCentroid.set(gid, latlng);
      geoState.gidToName.set(gid, nm);
    }
  });

  showToast(`Loaded ${gj.features?.length||0} districts. You can add provinces and CSV.`);
});

// Provinces (ADM1) — thick border + labels
geojsonProvincesInput.addEventListener('change', async (e)=>{
  const file = e.target.files[0]; if(!file) return;
  const text = await file.text();
  let gj;
  try { gj = JSON.parse(text); } catch(err){ showToast('Invalid Provinces GeoJSON'); return; }

  if(geoState.provincesLayer){ mapState.instance.removeLayer(geoState.provincesLayer); }
  mapState.provinceLabelsLayer.clearLayers();

  const cs = getComputedStyle(document.documentElement);
  geoState.provincesLayer = L.geoJSON(gj, {
    style: ()=>({
      color: cs.getPropertyValue('--province-stroke').trim(),
      weight: parseFloat(cs.getPropertyValue('--province-weight')),
      fillOpacity:0
    })
  }).addTo(mapState.instance);

  // Province labels
  const proto = (gj.features && gj.features[0] && gj.features[0].properties) || {};
  const nmKey = ['NAME_1','ADM1_EN','NAME'].find(k=>proto && k in proto) || Object.keys(proto||{}).find(k=>/NAME/i.test(k));
  gj.features.forEach(f=>{
    let center;
    try { center = turf.center(f).geometry.coordinates; }
    catch(_) { try { center = turf.centroid(f).geometry.coordinates; } catch(err){ center = null; } }
    if(!center) return;
    const label = (nmKey && f.properties[nmKey]) ? String(f.properties[nmKey]) : '';
    const lbl = L.marker([center[1], center[0]], {
      icon: L.divIcon({ className:'province-label', html:`<span class="badge">${label}</span>`, iconSize:null }),
      interactive:false
    });
    mapState.provinceLabelsLayer.addLayer(lbl);
  });

  if(toggleProvLabels.checked){
    if(!mapState.instance.hasLayer(mapState.provinceLabelsLayer)) mapState.provinceLabelsLayer.addTo(mapState.instance);
  }else{
    if(mapState.instance.hasLayer(mapState.provinceLabelsLayer)) mapState.instance.removeLayer(mapState.provinceLabelsLayer);
  }

  showToast(`Loaded ${gj.features?.length||0} provinces.`);
});

/* ==================== CSV loader ==================== */
csvInput.addEventListener('change', async (e)=>{
  const file = e.target.files[0]; if(!file) return;
  Papa.parse(file, {
    header:true, skipEmptyLines:true,
    complete: (res)=> { try{ loadCSV(res.data); } catch(err){ console.error(err); showToast('CSV error: '+err.message); } },
    error: (err)=> showToast('CSV parse failed: '+err)
  });
});

function loadCSV(rows){
  dataState.samples = [];
  dataState.clusters.clear();
  dataState.clusterOrder = [];
  dataState.colorScale = null;

  const missingGIDs = new Set();
  let ok = 0;
  let bad = 0;

  for (const row of rows) {
    const gid = normalizeKey(
      row.GID_2 || row.GID_1 || row.AdmDiv2_GID || row.AdmDiv1_GID ||
      row.ADM2_PCODE || row.ADM1_PCODE || row.PCODE || row.gid || row.GID
    );
    const date = parseDateFlexible(row.CollectionDate || row.date || row.Date || row.collection_date);
    const clusterRaw = row.Cluster ?? row.cluster ?? row.CLUSTER;
    const cluster = (!clusterRaw || /^(NA|null|none|uncluster|unclustered)$/i.test(String(clusterRaw)))
      ? null
      : String(clusterRaw).trim();

    const nameFromCsv = normalizeKey(row.AdmDiv2 || row.AdminDiv2 || row.admdiv2 || row.adminDiv2);

    if (!gid || !date) { bad++; continue; }

    const latCSV = parseFloat(row.Latitude ?? row.latitude ?? row.lat);
    const lonCSV = parseFloat(row.Longitude ?? row.longitude ?? row.lon ?? row.lng);
    const csvHasCoords = !isNaN(latCSV) && !isNaN(lonCSV);
    const baseLatLng = csvHasCoords
      ? [latCSV, lonCSV]
      : cloneLatLngPair(geoState.gidToCentroid.get(gid));
    if (!baseLatLng) { missingGIDs.add(gid); continue; }

    const ll = jitterWithinDistrict(gid, baseLatLng);
    if (!ll) { missingGIDs.add(gid); continue; }

    const dayInt = Math.floor(date.getTime() / DAY_MS);
    const districtName = nameFromCsv || geoState.gidToName.get(gid) || gid;

    dataState.samples.push({
      gid,
      dayInt,
      cluster,
      baseLatLng: cloneLatLngPair(baseLatLng),
      latlng: ll,
      districtName
    });
    if (cluster) dataState.clusters.add(cluster);
    ok++;
  }

  if (ok === 0) {
    showToast('No valid rows found. Check column names and GIDs.');
    return;
  }

  const clustArr = Array.from(dataState.clusters.values()).sort();
  dataState.colorScale = d3.scaleOrdinal().domain(clustArr).range(PALETTE24);
  dataState.clusterOrder = clustArr.slice();

  legendState.selected.clear();

  timelineState.minDay = d3.min(dataState.samples, d => d.dayInt);
  timelineState.maxDay = d3.max(dataState.samples, d => d.dayInt);
  timelineState.currentDay = timelineState.minDay;

  timeSlider.min = String(timelineState.minDay);
  timeSlider.max = String(timelineState.maxDay);
  timeSlider.value = String(timelineState.currentDay);
  timeSlider.disabled = false;

  const byGidDisplayName = new Map();
  dataState.samples.forEach(s => {
    byGidDisplayName.set(s.gid, s.districtName || geoState.gidToName.get(s.gid) || s.gid);
  });
  const gidsSorted = Array.from(new Set(dataState.samples.map(s => s.gid)))
    .sort((a, b) => (byGidDisplayName.get(a) || '').localeCompare(byGidDisplayName.get(b) || ''));

  const fillSelect = (sel) => {
    sel.innerHTML = '';
    gidsSorted.forEach(g => {
      const opt = document.createElement('option');
      opt.value = g;
      opt.textContent = byGidDisplayName.get(g);
      sel.appendChild(opt);
    });
  };
  fillSelect(districtSelectA);
  fillSelect(districtSelectB);
  districtSelectA.selectedIndex = 0;
  districtSelectB.selectedIndex = Math.min(1, gidsSorted.length - 1);

  setPlaying(true);

  let msg = `Loaded ${ok} samples`;
  if (missingGIDs.size) { msg += ` | ${missingGIDs.size} GIDs not in GeoJSON`; }
  if (bad) { msg += ` | ${bad} rows skipped`; }
  showToast(msg, 4200);

  buildLegend();
  updateScene();
  updateTree();
}

function setPlaying(v){
  timelineState.playing = v;
  if (timelineState.timer) {
    clearInterval(timelineState.timer);
    timelineState.timer = null;
  }
  if (v && timelineState.minDay != null && timelineState.maxDay != null) {
    timelineState.timer = setInterval(() => {
      if (timelineState.currentDay == null) return;
      timelineState.currentDay += timelineState.stepDays;
      if (timelineState.currentDay > timelineState.maxDay) {
        timelineState.currentDay = timelineState.minDay;
      }
      timeSlider.value = String(timelineState.currentDay);
      updateScene();
    }, timelineState.stepIntervalMs);
  }
  updateScene();
}
playBtn.addEventListener('click', () => setPlaying(true));
pauseBtn.addEventListener('click', () => setPlaying(false));
resetBtn.addEventListener('click', () => {
  if (geoState.districtsLayer) {
    mapState.instance.removeLayer(geoState.districtsLayer);
    geoState.districtsLayer = null;
  }
  if (geoState.provincesLayer) {
    mapState.instance.removeLayer(geoState.provincesLayer);
    geoState.provincesLayer = null;
  }
  if (mapState.provinceLabelsLayer) {
    mapState.provinceLabelsLayer.clearLayers();
  }
  geoState.gidToCentroid.clear();
  geoState.gidToName.clear();
  geoState.gidToFeature.clear();

  dataState.samples = [];
  dataState.clusters.clear();
  dataState.clusterOrder = [];
  dataState.colorScale = null;

  legendState.selected.clear();

  if (mapState.markersLayer) mapState.markersLayer.clearLayers();
  if (mapState.countsLayer) mapState.countsLayer.clearLayers();

  timeSlider.value = 0;
  timeSlider.disabled = true;
  timelineState.minDay = null;
  timelineState.maxDay = null;
  timelineState.currentDay = null;
  setPlaying(false);

  geojsonDistrictsInput.value = '';
  geojsonProvincesInput.value = '';
  csvInput.value = '';
  tabInput.value = '';
  districtSelectA.innerHTML = '';
  districtSelectB.innerHTML = '';
  legendBox.innerHTML = '';

  treeState.data = null;
  treeState.zoomTransform = d3.zoomIdentity;
  d3.select('#treeSVG').selectAll('*').remove();
  if (treeBody) treeBody.style.display = 'none';
  if (treeToggle) treeToggle.textContent = 'Show genetic tree';
  document.getElementById('simTableWrap').innerHTML = '';
  showToast('Cleared. Load new files.');
});
speedDaysInput.addEventListener('change', () => {
  const parsed = Math.max(1, parseInt(speedDaysInput.value || '1', 10));
  timelineState.stepDays = parsed;
  if (timelineState.playing) setPlaying(true);
});
stepIntervalInput.addEventListener('change', () => {
  const parsed = Math.max(100, parseInt(stepIntervalInput.value || '600', 10));
  timelineState.stepIntervalMs = parsed;
  if (timelineState.playing) setPlaying(true);
});
windowDaysInput.addEventListener('change', () => {
  timelineState.windowDays = Math.max(1, parseInt(windowDaysInput.value || '21', 10));
  updateScene();
});
lifespanDaysInput.addEventListener('change', () => {
  timelineState.lifespanDays = Math.max(1, parseInt(lifespanDaysInput.value || '21', 10));
  updateScene();
});
markerSizeInput.addEventListener('change', () => {
  mapState.markerRadius = Math.max(1, parseInt(markerSizeInput.value || '5', 10));
  updateScene();
});
jitterMInput.addEventListener('change', () => {
  mapState.jitterMeters = Math.max(0, parseInt(jitterMInput.value || '75', 10));
  reJitterAll();
  updateScene();
});
timeSlider.addEventListener('input', () => {
  timelineState.currentDay = parseInt(timeSlider.value, 10);
  updateScene();
});
window.addEventListener('keydown', (e) => {
  if (e.code === 'Space') {
    e.preventDefault();
    setPlaying(!timelineState.playing);
  }
});
toggleCounts.addEventListener('change', () => {
  mapState.showCounts = toggleCounts.checked;
  if (mapState.showCounts) {
    if (mapState.countsLayer && !mapState.instance.hasLayer(mapState.countsLayer)) {
      mapState.countsLayer.addTo(mapState.instance);
    }
  } else if (mapState.countsLayer && mapState.instance.hasLayer(mapState.countsLayer)) {
    mapState.instance.removeLayer(mapState.countsLayer);
  }
  updateScene();
});
/* ==================== Legend (under charts) ==================== */
legendShowAllBtn.addEventListener('click', ()=>{
  legendState.selected.clear(); updateScene(); updateCharts(); refreshLegendActive(); updateTree();
});
legendHideAllBtn.addEventListener('click', ()=>{
  legendState.selected = new Set(['__NONE__']); updateScene(); updateCharts(); refreshLegendActive(); updateTree();
});
legendToggleBtn.addEventListener('click', ()=>{
  const isHidden = legendBox.style.display === 'none';
  legendBox.style.display = isHidden ? 'block' : 'none';
  legendToggleBtn.textContent = isHidden ? 'Hide' : 'Show';
});

/* ==================== Genetic tree toggle ==================== */
if (treeToggle && treeBody) {
  treeToggle.addEventListener('click', () => {
    const show = (treeBody.style.display === 'none' || treeBody.style.display === '');
    treeBody.style.display = show ? 'block' : 'none';
    treeToggle.textContent = show ? 'Hide genetic tree' : 'Show genetic tree';
  });
}

/* Zoom buttons for genetic tree */
if (treeZoomIn && treeZoomOut) {
  const svgEl = document.getElementById('treeSVG');
  const STEP = 1.2; // zoom multiplier per click

  treeZoomIn.addEventListener('click', () => {
    if (!treeState.zoom) return; // guard if tree not initialized yet
    const p = [svgEl.clientWidth/2, svgEl.clientHeight/2];
    d3.select(svgEl).transition().duration(160).call(treeState.zoom.scaleBy, STEP, p);
  });
  treeZoomOut.addEventListener('click', () => {
    if (!treeState.zoom) return; // guard if tree not initialized yet
    const p = [svgEl.clientWidth/2, svgEl.clientHeight/2];
    d3.select(svgEl).transition().duration(160).call(treeState.zoom.scaleBy, 1/STEP, p);
  });
}

function buildLegend(){
  if(!legendBox) return;
  legendBox.innerHTML = '';
  legendBox.style.display = 'block';
  if(legendToggleBtn) legendToggleBtn.textContent = 'Hide';
  const clustersList = Array.from(new Set(dataState.samples.map(s=> s.cluster || 'Unclustered'))).sort();
  clustersList.forEach(c=>{
    const row = document.createElement('div');
    row.className = 'legend-row';
    row.dataset.key = c;
    const sw = document.createElement('span');
sw.className = 'swatch';
const glyph = getClusterGlyph(c);
sw.innerHTML = svgLegendSwatch(glyph.shape, glyph.color);

    const lbl = document.createElement('span');
    lbl.textContent = c;
    row.appendChild(sw); row.appendChild(lbl);
    row.addEventListener('click', ()=>{
      if(legendState.selected.has('__NONE__')) legendState.selected.delete('__NONE__');
      if(legendState.selected.has(c)) { legendState.selected.delete(c); } else { legendState.selected.add(c); }
      updateScene(); updateCharts(); refreshLegendActive(); updateTree();
    });
    legendBox.appendChild(row);
  });
  refreshLegendActive();
}
function refreshLegendActive(){
  const rows = legendBox.querySelectorAll('.legend-row');
  rows.forEach(r=>{
    const key = r.dataset.key;
    const active = (legendState.selected.size===0) ? true
                  : (legendState.selected.has('__NONE__') ? false : legendState.selected.has(key));
    r.classList.toggle('inactive', !active);
  });
}
function clusterIsActive(name){
  if(legendState.selected.size===0) return true;
  if(legendState.selected.has('__NONE__')) return false;
  return legendState.selected.has(name || 'Unclustered');
}

/* ==================== Re-jitter ==================== */
function reJitterAll(){
  dataState.samples.forEach(s=>{
    let baseForBias = cloneLatLngPair(s.baseLatLng);
    if(!baseForBias){
      const centroid = cloneLatLngPair(geoState.gidToCentroid.get(s.gid));
      if(centroid){
        baseForBias = centroid;
      } else if(Array.isArray(s.latlng) && s.latlng.length >= 2){
        baseForBias = [s.latlng[0], s.latlng[1]];
      }
      if(baseForBias){
        s.baseLatLng = [baseForBias[0], baseForBias[1]];
      }
    }
    if(!baseForBias){ return; }
    s.latlng = jitterWithinDistrict(s.gid, baseForBias);
  });
}
/* ==================== Scene & Charts ==================== */
function updateScene(){
  if(timelineState.currentDay == null) return;
  const lookbackDays = Math.max(timelineState.windowDays, timelineState.lifespanDays);
  const startDay = timelineState.currentDay - (lookbackDays - 1);
  const dateStr = fmtDateFromDayInt(timelineState.currentDay);
  currentDateLabel.textContent = dateStr;
  dateTitle.textContent = dateStr;

  const inWindow = dataState.samples.filter(s => s.dayInt >= startDay && s.dayInt <= timelineState.currentDay);
  const visibleLife = inWindow.filter(s => (timelineState.currentDay - s.dayInt) <= (timelineState.lifespanDays - 1));

  if (mapState.markersLayer) {
    mapState.markersLayer.clearLayers();
  }
  const isAll = legendState.selected.size === 0;
  const isNone = legendState.selected.has('__NONE__');

  visibleLife.forEach(s => {
    const key = s.cluster || 'Unclustered';
    const glyph = getClusterGlyph(key);
    const ageDays = timelineState.currentDay - s.dayInt;
    const baseAlpha = Math.max(0.25, 1 - (ageDays / Math.max(1, timelineState.lifespanDays)));
    const active = isAll ? true : (!isNone && legendState.selected.has(key));

    const icon = svgMarkerIcon({
      shape: glyph.shape,
      color: glyph.color,
      size: mapState.markerRadius,
      fillOpacity: active ? (0.35 + 0.55 * baseAlpha) : 0,
      strokeOpacity: active ? 1 : 0.7
    });

    L.marker(s.latlng, { icon })
      .bindTooltip(`${geoState.gidToName.get(s.gid) || s.gid}<br><strong>${s.cluster || 'Unclustered'}</strong><br>${fmtDateFromDayInt(s.dayInt)}`)
      .addTo(mapState.markersLayer);
  });

  if (mapState.countsLayer) {
    mapState.countsLayer.clearLayers();
  }
  if (mapState.showCounts && mapState.countsLayer) {
    const counts = d3.rollup(visibleLife, v => v.length, s => s.gid);
    for (const [gid, count] of counts) {
      const center = geoState.gidToCentroid.get(gid);
      if (!center) continue;
      const icon = L.divIcon({ className:'', html:`<div class="count-badge">${count}</div>` });
      L.marker(center, { icon, interactive:false }).addTo(mapState.countsLayer);
    }
  }

  updateCharts();
}/* Charts */
const CH_W = 380, CH_H = 180, M = {top:16,right:10,bottom:60,left:40};
function makeChart(svgSel){
  const el = d3.select(svgSel);
  el.attr('width', CH_W).attr('height', CH_H);
  const g = el.append('g').attr('transform', `translate(${M.left},${M.top})`);
  return {
    g,
    gXAxis: g.append('g').attr('transform', `translate(0,${CH_H - M.top - M.bottom})`),
    gYAxis: g.append('g'),
    gBars:  g.append('g'),
    innerW: CH_W - M.left - M.right,
    innerH: CH_H - M.top - M.bottom
  };
}
const CA = makeChart('#chartA');
const CB = makeChart('#chartB');

districtSelectA.addEventListener('change', updateCharts);
districtSelectB.addEventListener('change', updateCharts);
alignAxisToggle.addEventListener('change', updateCharts);

function monthKeyFromDayInt(dayInt){
  const dt = new Date(dayInt*DAY_MS);
  return `${dt.getFullYear()}-${String(dt.getMonth()+1).padStart(2,'0')}`;
}
function monthKeysWindow(endDayInt, n=36){
  const end = new Date(endDayInt*DAY_MS);
  const endY = end.getUTCFullYear();
  const endM = end.getUTCMonth();
  const keys = [];
  for(let i=n-1;i>=0;i--){
    const d = new Date(Date.UTC(endY, endM - i, 1));
    keys.push(`${d.getUTCFullYear()}-${String(d.getUTCMonth()+1).padStart(2,'0')}`);
  }
  return keys;
}

function renderChartInto(groups, selectedGID, titleText, monthsDomain=null){
  const { g, gXAxis, gYAxis, gBars, innerW, innerH } = groups;
  gBars.selectAll('*').remove(); gXAxis.selectAll('*').remove(); gYAxis.selectAll('*').remove();
  if(!selectedGID) return;

  const upto = timelineState.currentDay ?? timelineState.maxDay ?? 0;
  const rowsAll = dataState.samples.filter(s => s.gid===selectedGID && s.dayInt <= upto);

  const months = monthsDomain && monthsDomain.length
                  ? monthsDomain.slice()
                  : Array.from(new Set(rowsAll.map(r=>monthKeyFromDayInt(r.dayInt)))).sort();

  const clusterNames = Array.from(new Set(rowsAll.map(r=> r.cluster || 'Unclustered'))).sort();

  const monthToCounts = new Map(months.map(m=>[m, Object.fromEntries(clusterNames.map(c=>[c,0]))]));
  rowsAll.forEach(r=>{
    const mk = monthKeyFromDayInt(r.dayInt);
    if(!monthToCounts.has(mk)){
      if(!monthsDomain){ monthToCounts.set(mk, Object.fromEntries(clusterNames.map(c=>[c,0]))); months.push(mk); }
      else return;
    }
    monthToCounts.get(mk)[r.cluster || 'Unclustered'] += 1;
  });
  months.sort();
  const data = months.map(m=> ({ month:m, ...(monthToCounts.get(m) || {}) }));

  const x = d3.scaleBand().domain(months).range([0, innerW]).padding(0.1);
  const yMax = data.length ? d3.max(data, d => d3.sum(clusterNames, c => d[c]||0)) : 1;
  const y = d3.scaleLinear().domain([0, yMax]).nice().range([innerH, 0]);

  const color = (name) => getClusterGlyph(name).color;
  const stack = d3.stack().keys(clusterNames);
  const series = stack(data);

  const fadeVal = parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--fade'));
  const layerG = gBars.selectAll('g.layer').data(series, d=>d.key)
    .join(enter => enter.append('g').attr('class','layer'))
    .attr('fill', d => color(d.key))
    .attr('opacity', d => {
      if(legendState.selected.size===0) return 1;
      if(legendState.selected.has('__NONE__')) return 0.05;
      return legendState.selected.has(d.key) ? 1 : fadeVal;
    });

  layerG.selectAll('rect')
    .data(d => d.map(v => ({key:d.key, month:v.data.month, y0:v[0], y1:v[1]})))
    .join('rect')
    .attr('x', d => x(d.month))
    .attr('y', d => y(d.y1))
    .attr('height', d => Math.max(0, y(d.y0) - y(d.y1)))
    .attr('width', x.bandwidth());

  gXAxis.call(d3.axisBottom(x).tickValues(months));
  gXAxis.selectAll('text').attr('transform','rotate(-90)').style('text-anchor','end').attr('dx','-8px').attr('dy','-4px');
  gYAxis.call(d3.axisLeft(y).ticks(4));

  g.selectAll('text.title').data([0]).join('text')
    .attr('class','title').attr('x',0).attr('y',-6)
    .attr('fill', getComputedStyle(document.documentElement).getPropertyValue('--muted'))
    .attr('font-size','12px')
    .text(titleText + ' — to ' + fmtDateFromDayInt(timelineState.currentDay ?? timelineState.minDay ?? upto));
}

/* ==================== Genetic distances (.tab) — NJ tree ==================== */
tabInput.addEventListener('change', async (e)=>{
  const file = e.target.files[0]; if(!file) return;
  const text = await file.text();
  treeState.data = parseDistanceTab(text);
  if(!treeState.data){ showToast('Could not parse genetic distance .tab (needs "Cluster" header and square matrix).'); return; }
  showToast(`Loaded genetic distances for ${treeState.data.labels.length} clusters.`);
  updateTree();
});

function parseDistanceTab(text){
  const rows = text.replace(/^\uFEFF/, '').trim().split(/\r?\n/)
                   .map(r => r.split(/\t/).map(s => String(s||'').trim()));
  if(rows.length < 2) return null;
  const header = rows[0];
  const labels = header.slice(1).map(s => s.replace(/^"+|"+$/g,'').trim());
  if(labels.length < 2) return null;

  const n = labels.length;
  const indexByLabel = new Map(labels.map((l,i)=>[l,i]));
  const M = Array.from({length:n}, () => Array(n).fill(0));

  for(let r=1; r<rows.length; r++){
    const row = rows[r];
    if(!row.length) continue;
    const lab = (row[0]||'').replace(/^"+|"+$/g,'').trim();
    if(!indexByLabel.has(lab)) continue;
    const i = indexByLabel.get(lab);
    for(let c=1; c<=n; c++){
      const cell = (row[c] ?? '').replace(',', '.');
      const v = parseFloat(cell);
      if(!isNaN(v)) M[i][c-1] = v;
    }
  }

  // Symmetrize, clamp [0,1], diag=0
  for(let i=0;i<n;i++){
    for(let j=0;j<n;j++){
      if(i===j){ M[i][j]=0; continue; }
      const a = M[i][j], b = M[j][i];
      let v = (isFinite(a)&&isFinite(b)) ? (a+b)/2 : (isFinite(a)?a:(isFinite(b)?b:1));
      M[i][j] = Math.max(0, Math.min(1, v));
    }
  }
  return { labels, matrix: M };
}

/* Neighbor-Joining to adjacency (unrooted); also returns the ID of the final join node */
function buildNJAdjacency(subsetLabels){
  const all = treeState.data.labels;
  const idx = subsetLabels.map(l => all.indexOf(l));
  if(idx.some(i => i < 0)) return null;

  // Working subset distance matrix
  let D = idx.map(i => idx.map(j => treeState.data.matrix[i][j]));
  let ids = subsetLabels.slice();

  const edges = [];
  let internalCounter = 0;

  function rowSums(mat){
    const n = mat.length, r = Array(n).fill(0);
    for(let i=0;i<n;i++) for(let j=0;j<n;j++) r[i]+=mat[i][j];
    return r;
  }

  while(ids.length > 2){
    const n = D.length;
    const R = rowSums(D);

    let bi=0,bj=1,best=Infinity;
    for(let i=0;i<n;i++){
      for(let j=i+1;j<n;j++){
        const Q = (n-2)*D[i][j] - R[i] - R[j];
        if(Q < best){ best = Q; bi=i; bj=j; }
      }
    }

    const Dij = D[bi][bj];
    const delta = (R[bi] - R[bj]) / (n-2);
    let Li = Math.max(0, 0.5*(Dij + delta));
    let Lj = Math.max(0, Dij - Li);

    const newId = `NJ#${++internalCounter}`;
    edges.push([newId, ids[bi], Li]);
    edges.push([newId, ids[bj], Lj]);

    // New distances to remaining taxa
    const newRow = [];
    for(let k=0;k<n;k++){
      if(k===bi || k===bj){ newRow.push(0); continue; }
      const Duk = Math.max(0, Math.min(1, 0.5*(D[bi][k] + D[bj][k] - Dij)));
      newRow.push(Duk);
    }

    const keep = [];
    for(let k=0;k<n;k++) if(k!==bi && k!==bj) keep.push(k);
    const Dnext = Array.from({length: keep.length+1}, () => Array(keep.length+1).fill(0));
    for(let a=0;a<keep.length;a++) for(let b=0;b<keep.length;b++) Dnext[a][b] = D[keep[a]][keep[b]];
    const u = keep.length;
    for(let a=0;a<keep.length;a++){ Dnext[a][u] = newRow[keep[a]]; Dnext[u][a] = newRow[keep[a]]; }
    D = Dnext;

    const nextIds = keep.map(k => ids[k]); nextIds.push(newId); ids = nextIds;
  }

  // Final join (two nodes remain)
  const Dij2 = D[0][1];
  const a = ids[0], b = ids[1];
  const finalRoot = `NJ#root`;
  edges.push([finalRoot, a, Math.max(0, Dij2/2)]);
  edges.push([finalRoot, b, Math.max(0, Dij2/2)]);

  // Build adjacency
  const adj = new Map();
  function addEdge(u,v,len){
    if(!adj.has(u)) adj.set(u, []);
    if(!adj.has(v)) adj.set(v, []);
    adj.get(u).push({id:v, w:len});
    adj.get(v).push({id:u, w:len});
  }
  edges.forEach(([u,v,w]) => addEdge(u,v,w));
  return {adj, rootId: finalRoot};
}

/* Convert rooted adjacency into a d3-friendly tree with edgeLength on each child node */
function buildDirectedTree(adjacency, rootId){
  function dfs(u, parent=null){
    const children = [];
    for(const {id:v, w} of adjacency.get(u)){
      if(v === parent) continue;
      const child = dfs(v, u);
      child.edgeLength = w;
      children.push(child);
    }
    return { name: u, children };
  }
  return dfs(rootId, null);
}

/* Draw rectangular phylogram scaled by cumulative branch length. */
function updateTree(){
  const svg = d3.select('#treeSVG');
  const note = treeNote;
  svg.selectAll('*').remove();
  note.textContent = '';

  if(!treeState.data){
    note.textContent = 'Load a genetic distance .tab to display the tree.';
    return;
  }

  // Selection: legend subset or all clusters from CSV; omit "Unclustered"
  let sel = (legendState.selected.size && !legendState.selected.has('__NONE__'))
    ? Array.from(legendState.selected)
    : Array.from(dataState.clusters);
  sel = sel.filter(c => c && c !== 'Unclustered');

  // Keep order consistent with matrix header & keep only present labels
  const present = treeState.data.labels.filter(l => sel.includes(l));
  if(present.length < 2){
    note.textContent = sel.length ? 'Not enough clusters (need >= 2 that exist in the matrix).' : 'No clusters selected.';
    document.getElementById('simTableWrap').innerHTML = '';
    return;
  }

  // Build NJ adjacency and use its final join as root (no midpoint rooting)
  const nj = buildNJAdjacency(present);
  if(!nj){ note.textContent = 'Failed to build NJ tree for the selection.'; return; }
  const {adj, rootId} = nj;

  const tree = buildDirectedTree(adj, rootId);
  const root = d3.hierarchy(tree, d => (d.children && d.children.length ? d.children : null));

  // cumulative length from root
  root.each(n => { n.data.cum = (n.parent ? (n.parent.data.cum||0) + (n.data.edgeLength||0) : 0); });
  const maxCum = d3.max(root.descendants(), d => d.data.cum || 0) || 1;

  // Canvas and groups (extra right padding for labels so tips never go out of view)
  const W = document.getElementById('treeSVG').clientWidth || 320;
  const H = document.getElementById('treeSVG').clientHeight || 300;
  const labelPad = 110; // space for text at the right
  const margin = {top:10,right:labelPad,bottom:10,left:60};
  const innerW = W - margin.left - margin.right;
  const innerH = H - margin.top - margin.bottom;

  const pane = svg.append('g').attr('class','tree-pane'); // this group will be panned/zoomed
const g = pane.append('g').attr('transform', `translate(${margin.left},${margin.top})`);

// init or rebind zoom (drag to pan, wheel/pinch to zoom)
if (!treeState.zoom) {
  treeState.zoom = d3.zoom()
    .scaleExtent([0.6, 6])
    .on('zoom', (ev) => {
      d3.select('#treeSVG g.tree-pane').attr('transform', ev.transform);
      treeState.zoomTransform = ev.transform;
    });
}
svg.call(treeState.zoom)                      // attach behavior
   .call(treeState.zoom.transform, treeState.zoomTransform); // restore previous view


  // vertical positions via d3.cluster; horizontal = cumulative length
  d3.cluster().size([innerH, 1])(root);
  const x = d3.scaleLinear().domain([0, maxCum]).range([0, innerW]);
  root.each(n => { n.y = x(n.data.cum||0); });

  // Links
  const link = d3.linkHorizontal().x(d => d.y).y(d => d.x);
  g.selectAll('path.link')
    .data(root.links())
    .join('path')
    .attr('class','link')
    .attr('fill','none')
    .attr('stroke','var(--muted)')
    .attr('stroke-width', 2)
    .attr('d', link);

  // Nodes: leaves with cluster colours; internal small gray dots
  const leaves = root.leaves();
  // Leaves: shape consistent with legend
const leafSel = g.selectAll('.leaf-shape')
  .data(leaves)
  .join('g')
  .attr('class','leaf-shape')
  .attr('transform', d => `translate(${d.y},${d.x})`);

leafSel.each(function(d){
  const key = d.data.name;
  const glyph = getClusterGlyph(key);

  const sel = d3.select(this);
  sel.selectAll('*').remove();

  if(glyph.shape==='circle'){
    sel.append('circle').attr('r',5).attr('fill',glyph.color);
  }else if(glyph.shape==='square'){
    sel.append('rect').attr('x',-5).attr('y',-5).attr('width',10).attr('height',10).attr('fill',glyph.color);
  }else if(glyph.shape==='diamond'){
    sel.append('rect').attr('x',-5).attr('y',-5).attr('width',10).attr('height',10)
       .attr('transform','rotate(45)').attr('fill',glyph.color);
  }else if(glyph.shape==='triangle'){
    sel.append('polygon').attr('points','0,-6 6,6 -6,6').attr('fill',glyph.color);
  }
});

// Labels
 g.selectAll('text.leaf')
    .data(leaves)
    .join('text')
    .attr('x', d=>d.y + 8)
    .attr('y', d=>d.x + 4)
    .style('fill','var(--text)')
    .style('font-size','12px')
    .text(d=>d.data.name);

  const internals = root.descendants().filter(d => d.children && d.children.length && !present.includes(d.data.name));
  g.selectAll('circle.internal')
    .data(internals)
    .join('circle')
    .attr('class','internal')
    .attr('cx', d=>d.y)
    .attr('cy', d=>d.x)
    .attr('r', 2.5)
    .attr('fill', '#9ca3af');

  // Legend
  const legend = d3.select("#treeLegend");
  legend.html(`<div class="chip">Tips colored by cluster; vertical spacing is arbitrary; horizontal = cumulative branch length.</div>`);

  // Similarity table for selected clusters
  renderSimilarityTable(present);
}

/* ---------- Similarity table ---------- */
function renderSimilarityTable(selectedLabels){
  if(!treeState.data){ document.getElementById('simTableWrap').innerHTML = ''; return; }
  const idx = selectedLabels.map(l => treeState.data.labels.indexOf(l));
  const rows = [];
  for(let i=0;i<idx.length;i++){
    for(let j=i+1;j<idx.length;j++){
      const a = selectedLabels[i], b = selectedLabels[j];
      const d = treeState.data.matrix[idx[i]][idx[j]];
      const sim = Math.max(0, Math.min(1, 1 - d)); // 0..1
      rows.push({cluster_a:a, cluster_b:b, similarity: sim});
    }
  }
  rows.sort((r1,r2)=> r2.similarity - r1.similarity);

  const wrap = document.getElementById('simTableWrap');
  if(rows.length===0){ wrap.innerHTML = '<div style="font-size:12px; color:var(--muted)">No pairs.</div>'; return; }

  const table = document.createElement('table');
  table.id = 'simTable';
  table.innerHTML = `
    <thead><tr><th>cluster_a</th><th>cluster_b</th><th>genetic similarity</th></tr></thead>
    <tbody>
      ${rows.map(r => `<tr><td>${r.cluster_a}</td><td>${r.cluster_b}</td><td>${(r.similarity*100).toFixed(1)}%</td></tr>`).join('')}
    </tbody>`;
  wrap.innerHTML = '';
  wrap.appendChild(table);
}

/* ==================== Charts update wrapper ==================== */
function updateCharts(){
  const aligned = alignAxisToggle.checked;
  const alignedDomain = aligned && timelineState.currentDay != null ? monthKeysWindow(timelineState.currentDay, 36) : null;
  const gidA = districtSelectA.value || null;
  const gidB = districtSelectB.value || null;
  renderChartInto(CA, gidA, (geoState.gidToName.get(gidA)||''), alignedDomain);
  renderChartInto(CB, gidB, (geoState.gidToName.get(gidB)||''), alignedDomain);
}
</script>
</body>
</html>

































































































































