<!DOCTYPE html>
<html lang="en" class="light">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>
      Genetic Epidemiology - Map + Timeline + Dual District Charts + Genetic
      Tree
    </title>
    <link
      rel="stylesheet"
      href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
    />
    <script src="https://unpkg.com/@mapbox/polylabel@1.1.0/polylabel.js"></script>

    <style>
      @import url("https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap");
      :root {
        --color-bg: #101526;
        --color-surface: #1b2337;
        --color-surface-alt: #232d45;
        --color-muted: #9da9c6;
        --color-text: #f4f7ff;
        --color-chip: #223048;
        --color-border: rgba(148, 163, 184, 0.35);
        --color-map-bg: #0d1627;
        --color-focus: rgba(96, 165, 250, 0.85);
        --color-accent: #4dd0e1;
        --color-accent-strong: #1fa2b7;
        --shadow-elevated: 0 18px 48px rgba(10, 14, 34, 0.45);
        --radius-lg: 18px;
        --radius-md: 12px;
        --radius-sm: 8px;
        --font-sans: "Inter", "Segoe UI", system-ui, -apple-system, sans-serif;
        --tl-h: 56px;
        --bg: var(--color-bg);
        --panel: var(--color-surface);
        --muted: var(--color-muted);
        --text: var(--color-text);
        --chip: var(--color-chip);
        --border: var(--color-border);
        --mapbg: var(--color-map-bg);
        --district-fill: #111726;
        --district-stroke: #3c4a66;
        --district-weight: 0.3;
        --province-stroke: #91a4bf;
        --province-weight: 1;
        --country-stroke: #f97316;
        --country-weight: 2;
        --label-badge-bg-province: var(--color-surface-alt);
        --label-badge-bg-country: #f97316;
        --label-badge-brd: var(--color-border);
        --label-color: #f4f7ff;
        --fade: 0.24;
        --fade-stroke: 0.38;
        --table-border: rgba(148, 163, 184, 0.22);
        --accent: var(--color-accent);
        --accent-contrast: #0b1a22;
      }
      html.light {
        --color-bg: #f7f9ff;
        --color-surface: #ffffff;
        --color-surface-alt: #f2f5ff;
        --color-muted: #5b647a;
        --color-text: #1b2337;
        --color-chip: #eff3fb;
        --color-border: rgba(15, 23, 42, 0.12);
        --color-map-bg: #d9e6f2;
        --color-focus: rgba(37, 99, 235, 0.75);
        --color-accent: #2563eb;
        --color-accent-strong: #1d4ed8;
        --bg: var(--color-bg);
        --panel: var(--color-surface);
        --muted: var(--color-muted);
        --text: var(--color-text);
        --chip: var(--color-chip);
        --border: var(--color-border);
        --mapbg: var(--color-map-bg);
        --district-fill: #ffffff;
        --district-stroke: #d0d7e6;
        --district-weight: 0.3;
        --province-stroke: #99a7bf;
        --province-weight: 1;
        --country-stroke: #c2410c;
        --country-weight: 2;
        --label-badge-bg: var(--color-surface-alt);
        --label-badge-brd: var(--color-border);
        --label-badge-bg-province: var(--color-surface-alt);
        --label-badge-bg-country: var(--country-stroke);
        --label-color: #1b2337;
        --fade: 0.32;
        --fade-stroke: 0.46;
        --table-border: rgba(148, 163, 184, 0.24);
        --accent: var(--color-accent);
        --accent-contrast: #ffffff;
      }

      html,
      body {
        height: 100%;
        margin: 0;
        font-family: var(--font-sans);
        background: var(--bg);
        color: var(--text);
      }
      body {
        overflow-x: hidden;
        background: var(--bg);
        color: var(--text);
      }
      *:focus-visible {
        outline: 2px solid var(--color-focus);
        outline-offset: 3px;
      }
      button:focus-visible,
      input:focus-visible,
      select:focus-visible {
        box-shadow: 0 0 0 3px rgba(77, 208, 225, 0.28);
      }

      #layout {
        display: grid;
        grid-template-rows: 1fr auto;
        height: 100vh;
      }

      /* Map */
      #mapWrap {
        position: relative;
      }
      #map {
        height: 100%;
        width: 100%;
        background: var(--mapbg);
      }
      .province-label {
        color: var(--label-color);
        font-size: 12px;
        font-weight: 700;
        text-shadow: 0 1px 0 rgba(0, 0, 0, 0.35);
        transform: translate(-50%, -50%);
        pointer-events: none;
      }
      .province-label .badge {
        display: inline-block;
        padding: 2px 8px;
        border-radius: 12px;
        background: var(--label-badge-bg-province);
        border: 1px solid var(--label-badge-brd);
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
      }
      .country-label {
        color: var(--label-color);
        font-size: 13px;
        font-weight: 700;
        text-align: center;
        text-shadow: 0 1px 0 rgba(0, 0, 0, 0.35);
        transform: translate(-50%, -50%);
        pointer-events: none;
      }
      .country-label .badge {
        display: inline-block;
        padding: 2px 12px;
        border-radius: 14px;
        background: var(--label-badge-bg-country);
        border: 1px solid var(--label-badge-brd);
        box-shadow: 0 2px 6px rgba(0, 0, 0, 0.15);
      }
      .count-badge {
        background: rgba(0, 0, 0, 0.55);
        color: #fff; 
        display: inline-block;
        border: 1px solid rgba(255, 255, 255, 0.2);
        padding: 1px 6px;
        border-radius: 999px;
        font-size: 11px;
        font-weight: 700;
      }

      /* Date title (top centered) */
      #dateTitle {
        position: absolute;
        top: 10px;
        left: 50%;
        transform: translateX(-50%);
        z-index: 550;
        font-size: 22px;
        font-weight: 800;
        letter-spacing: 0.02em;
        background: var(--color-surface-alt);
        border: 1px solid var(--border);
        padding: 8px 18px;
        border-radius: var(--radius-md);
        box-shadow: var(--shadow-elevated);
      }

      /* Left controls */
      #leftPanel {
        position: absolute;
        top: 56px;
        left: 12px;
        z-index: 800;
        background: var(--panel);
        border: 1px solid var(--border);
        border-radius: var(--radius-lg);
        padding: 16px;
        width: 350px;
        box-shadow: var(--shadow-elevated);
        max-height: calc(90vh - 100px);
        overflow: auto;
      }
      #leftPanel h2 {
        font-size: 13px;
        margin: 0 0 6px 0;
        opacity: 0.85;
        text-transform: uppercase;
        letter-spacing: 0.08em;
      }
      .ctrl {
        display: flex;
        align-items: center;
        gap: 8px;
        margin: 6px 0;
        font-size: 12px;
      }
      .ctrl label {
        min-width: 170px;
        color: var(--muted);
      }
      .ctrl input[type="number"] {
        width: 90px;
      }
      .btn {
        background: rgba(255, 255, 255, 0.04);
        border: 1px solid var(--border);
        color: var(--text);
        border-radius: var(--radius-sm);
        padding: 6px 12px;
        cursor: pointer;
        font-size: 12px;
        transition: background-color 120ms ease, border-color 120ms ease,
          color 120ms ease;
      }
      .btn:hover {
        background: rgba(255, 255, 255, 0.08);
        border-color: rgba(255, 255, 255, 0.2);
      }
      .btn:disabled {
        opacity: 0.55;
        cursor: not-allowed;
        background: rgba(255, 255, 255, 0.04);
      }
      #toast {
        position: absolute;
        left: 50%;
        transform: translateX(-50%);
        top: 12px;
        background: var(--panel);
        border: 1px solid var(--border);
        color: var(--text);
        border-radius: var(--radius-md);
        padding: 10px 14px;
        font-size: 12px;
        display: none;
        z-index: 600;
        box-shadow: var(--shadow-elevated);
      }

      /* Right charts + legend (legend under charts) */
      #rightPanel {
        position: absolute;
        top: 56px;
        right: 12px;
        z-index: 800;
        background: var(--panel);
        border: 1px solid var(--border);
        border-radius: var(--radius-lg);
        padding: 16px;
        width: 440px;
        box-shadow: var(--shadow-elevated);
        max-height: calc(90vh - 100px);
        overflow: auto;
      }

      #rightPanel h2 {
        font-size: 13px;
        margin: 0 0 6px 0;
        opacity: 0.85;
        text-transform: uppercase;
        letter-spacing: 0.08em;
      }
      #chartA,
      #chartB {
        width: 100%;
        height: 220px;
      }
      .chip {
        display: inline-block;
        background: var(--chip);
        border: 1px solid var(--border);
        border-radius: 999px;
        padding: 2px 8px;
        font-size: 12px;
        color: var(--muted);
      }
      .chip.success-chip {
        background: rgba(34, 197, 94, 0.16);
        border-color: rgba(34, 197, 94, 0.5);
        color: #34d399;
        font-weight: 600;
      }
      .legend-row {
        display: flex;
        font-size: 13px;
        align-items: center;
        gap: 8px;
        margin: 4px 0;
        cursor: pointer;
        padding: 4px 6px;
        border-radius: var(--radius-sm);
        transition: background-color 120ms ease, opacity 120ms ease;
      }
      .legend-row:hover {
        background: rgba(255, 255, 255, 0.06);
      }
      .legend-row.inactive {
        opacity: 0.45;
      }
      .swatch {
        width: 16px;
        height: 16px;
        display: inline-flex;
        align-items: center;
        justify-content: center;
        border: none;
        padding: 0;
        background: none;
      }
      .legend-actions {
        display: flex;
        gap: 6px;
        margin: 6px 0;
      }
      .legend-actions button {
        font-size: 12px;
        padding: 3px 6px;
        border: 1px solid var(--border);
        background: transparent;
        color: var(--text);
        border-radius: 6px;
        cursor: pointer;
      }
      .panel-header {
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 8px;
      }
      .panel-header h2 {
        margin: 0;
      }
      .panel-hide-btn {
        padding: 4px 8px;
        font-size: 11px;
        border-radius: 999px;
      }
      .panel-toggle-button {
        position: absolute;
        top: 16px;
        z-index: 750;
        background: var(--color-surface-alt);
        border: 1px solid var(--border);
        color: var(--text);
        border-radius: var(--radius-md);
        padding: 6px 12px;
        font-size: 11px;
        cursor: pointer;
        box-shadow: var(--shadow-elevated);
        transition: background-color 120ms ease, border-color 120ms ease;
        display: inline-flex;
        align-items: center;
        gap: 6px;
      }
      .panel-toggle-button:hover {
        background: var(--panel);
      }
      .panel-toggle-button:focus-visible {
        outline: 2px solid var(--accent);
        outline-offset: 2px;
      }
      #showLeftPanelBtn {
        left: 16px;
      }
      #showRightPanelBtn {
        right: 50px;
      }
      #leftPanel,
      #rightPanel {
        transition: transform 0.25s ease, opacity 0.25s ease;
      }
      #leftPanel.is-hidden {
        transform: translateX(-120%);
        opacity: 0;
        pointer-events: none;
      }
      #rightPanel.is-hidden {
        transform: translateX(120%);
        opacity: 0;
        pointer-events: none;
      }

      select,
      input,
      button {
        font: inherit;
      }

      /* Bottom timeline */
      #timelineBar {
        position: absolute;
        bottom: 0;
        left: 220px; /* Leave space for buttons on left */
        right: 60px;
        width:auto;
        height: var(--tl-h);
        display: grid;
        grid-template-columns: 1fr auto;
        gap: 12px;
        align-items: center;
        padding: 8px 12px;
        background: var(--panel);
        color: var(--text);
        border-top: 1px solid var(--border);
        z-index: 600;
      }
      #timeSlider {
        width: 100%;
      }
      .pill {
        background: var(--chip);
        border: 1px solid var(--border);
        color: var(--muted);
        padding: 4px 8px;
        border-radius: 999px;
        font-size: 12px;
      }

      /* Bottom left player controls */
#bottomPlayerControls {
  position: absolute;
  bottom: 15px;
  left: 8px;
  z-index: 650;
  display: flex;
  align-items: center;
  gap: 6px;
  background: var(--panel);
  border: 1px solid var(--border);
  border-radius: var(--radius-md);
  padding: 8px 12px;
  box-shadow: var(--shadow-elevated);
}

/* Smaller timeline buttons */
.timeline-btn {
  padding: 4px 8px !important;
  font-size: 11px !important;
}

.timeline-chip {
  font-size: 10px;
  padding: 2px 6px;
  margin-left: 4px;
}


      /* Genetic tree panel */
      #treePanel {
        margin-top: 10px;
        padding-top: 8px;
        border-top: 1px solid var(--border);
      }
      #treePanel h2 {
        font-size: 13px;
        margin: 0 0 6px 0;
        opacity: 0.85;
        text-transform: uppercase;
        letter-spacing: 0.08em;
      }
      #treeSVG {
        width: 100%;
        height: 300px;
        overflow: visible;
        display: block;
        cursor: grab;
        user-select: none;
        touch-action: none;
      } /* ? ensure tips/labels are visible */
      #treeLegend {
        margin-top: 6px;
        font-size: 12px;
      }
      /* Collapsible table */
      details#simDetails {
        margin-top: 8px;
        border-top: 1px dashed var(--border);
        padding-top: 8px;
      }
      #simTable {
        width: 100%;
        border-collapse: collapse;
        font-size: 12px;
        margin-top: 6px;
      }
      #simTable th,
      #simTable td {
        border: 1px solid var(--table-border);
        padding: 4px 6px;
        text-align: left;
      }
      #simTable th {
        background: rgba(255, 255, 255, 0.06);
        color: var(--text);
      }

  /* Onboarding overlay + spotlight */
  .tour-backdrop {
    position: fixed; inset: 0;
    background: rgba(0,0,0,0.55);
    z-index: 9998;
    display: none;
  }
  .tour-spotlight {
    position: absolute;
    border: 2px solid rgba(255,255,255,0.7);
    border-radius: 12px;
    box-shadow: 0 0 0 20000px rgba(0,0,0,0.55);
    pointer-events: none;
    z-index: 9999;
    display: none;
  }
.tour-tooltip {
  position: fixed;              /* <-- needed so top/left from JS work */
  z-index: 10000;               /* above backdrop (9998) and spotlight (9999) */
  max-width: 520px;
  padding: 16px 18px 14px;
  line-height: 1.45;
  background: var(--panel, #1F2937);
  color: var(--text, #EAEFF6);
  border: 1px solid var(--border, #3C3F4A);
  border-radius: 12px;
  box-shadow: 0 10px 30px rgba(0,0,0,.45);
  display: none;                /* default hidden; JS toggles to block */
}
.tour-tooltip h4 {
  font-size: 18px;              /* larger title */
  margin: 0 0 10px;
}
.tour-tooltip p {               /* clear space between text and buttons */
  margin: 0 0 12px;
}
.tour-actions {                 /* ensure spacing below text */
  margin-top: 10px;
}
.tour-actions button.link {     /* make skip clearly clickable */
  cursor: pointer;
  opacity: .9;
}
.tour-target-focus {            /* bring highlight ABOVE dim */
  position: relative;
  z-index: 10001;               /* > tooltip/backdrop z-index */
  outline: 3px solid rgba(59,130,246,.65);
  outline-offset: 2px;
  border-radius: 10px;
}
.tour-heading {
  display: flex;
  align-items: center;
  gap: 0.75rem;
  font-size: large;
}
.tour-logo {
  width: 120px;
  max-width: 100%;
  display: block;
}
  .tour-actions button.primary { background: #3b82f6; border-color: #3b82f6; color: #fff; }
  .tour-actions button.link { background: transparent; border: none; text-decoration: underline; color: var(--muted,#A5B1C2); }

  /* Subtle highlight when focusing a target */
  .tour-target-focus { outline: 3px solid rgba(59,130,246,.65); outline-offset: 2px; border-radius: 10px; transition: outline-color .2s; }
  /* Floating help FAB */
.help-fab{
  position: fixed;
  top: 12px;
  right: 12px;
  width: 36px;
  height: 36px;
  border-radius: 9999px;
  border: 1px solid var(--border, #3C3F4A);
  background: var(--chip, #27304A);
  color: var(--text, #EAEFF6);
  font-weight: 700;
  line-height: 34px;
  text-align: center;
  cursor: pointer;
  z-index: 10002; /* above backdrop/spotlight */
}
@keyframes fab-pulse {
  0%   { box-shadow: 0 0 0 0 rgba(59,130,246,.55); }
  70%  { box-shadow: 0 0 0 14px rgba(59,130,246,0); }
  100% { box-shadow: 0 0 0 0 rgba(59,130,246,0); }
}
.help-fab.pulse {
  animation: fab-pulse 2s ease-out infinite;
}
.help-fab:focus{ outline: 2px solid rgba(59,130,246,.6); outline-offset: 2px; }

      #mapChoiceModal {
        position: fixed;
        inset: 0;
        background: rgba(5, 9, 22, 0.78);
        display: none;
        align-items: center;
        justify-content: center;
        padding: 24px;
        z-index: 12000;
      }
      #mapChoiceModal.show {
        display: flex;
      }
      .map-choice-card {
        width: 100%;
        max-width: 480px;
        background: var(--panel);
        border-radius: var(--radius-lg);
        border: 1px solid var(--border);
        padding: 28px 26px;
        box-shadow: var(--shadow-elevated);
        display: flex;
        flex-direction: column;
        gap: 12px;
      }
      .map-choice-card h3 {
        margin: 0;
        font-size: 20px;
      }
      .map-choice-card p {
        margin: 0;
        color: var(--muted);
        line-height: 1.5;
        font-size: 14px;
      }
      .map-choice-actions {
        margin-top: 8px;
        display: flex;
        flex-direction: column;
        gap: 10px;
      }
      .map-choice-card button {
        width: 100%;
        border-radius: var(--radius-md);
        border: 1px solid var(--border);
        padding: 12px 16px;
        font-size: 15px;
        font-weight: 600;
        cursor: pointer;
        transition: background 120ms ease, transform 120ms ease;
      }
      .map-choice-card button.primary {
        background: var(--color-accent);
        color: var(--accent-contrast);
        border-color: var(--color-accent);
      }
      .map-choice-card button.secondary {
        background: var(--chip);
        color: var(--text);
      }
      .map-choice-card button:disabled {
        opacity: 0.55;
        cursor: progress;
      }

</style>
  </head>
  <body>
    <div id="layout">
      <div id="mapWrap">
        <div id="map"></div>
        <div id="dateTitle">--</div>
        <button
          id="showLeftPanelBtn"
          class="panel-toggle-button btn"
          type="button"
          hidden
        >
          Show controls
        </button>
        <button
          id="showRightPanelBtn"
          class="panel-toggle-button btn"
          type="button"
          hidden
        >
          Show charts
        </button>

        <!-- Left control panel -->
        <aside id="leftPanel" aria-label="Controls">
           <section id="DataSection">
          <div class="panel-header">
            <h2>Data</h2>
            <button
              id="hideLeftPanelBtn"
              class="btn panel-hide-btn"
              type="button"
            >
              Hide controls
            </button>
          </div>
          <div id="geojsonInputGroup">
            <div class="ctrl">
              <label>Districts ADM2 (.geojson)</label
              ><input
                id="geojsonDistrictsFile"
                type="file"
                accept=".geojson,.json,application/geo+json"
              />
            </div>
            <div class="ctrl">
              <label>Provinces ADM1 (.geojson)</label
              ><input
                id="geojsonProvincesFile"
                type="file"
                accept=".geojson,.json,application/geo+json"
              />
            </div>
            <div class="ctrl">
              <label>Country ADM0 (.geojson)</label
              ><input
                id="geojsonCountriesFile"
                type="file"
                accept=".geojson,.json,application/geo+json"
              />
            </div>
          </div>
          <div
            id="easternGmsNotice"
            class="chip success-chip"
            style="display: none"
          >
            Eastern GMS map successfully loaded.
          </div>
          <div class="ctrl">
            <label>Sample Data (.csv)</label
            ><input id="csvFile" type="file" accept=".csv" />
          </div>
          </section>

          <!-- Separator line -->
          <hr class="panel-separator">
          <h2>Controls</h2>

          <!-- Controls section -->
          <div class="ctrl">
            <label>Days / step</label
            ><input id="speedDays" type="number" min="1" value="7" />
          </div>
          <div class="ctrl">
            <label>Step (ms)</label
            ><input
              id="stepInterval"
              type="number"
              min="100"
              step="100"
              value="1000"
            />
          </div>
          <div class="ctrl">
            <label>Window (days)</label
            ><input id="windowDays" type="number" min="1" value="30" />
          </div>
          <div class="ctrl">
            <label>Lifespan (days)</label
            ><input id="lifespanDays" type="number" min="1" value="60" />
          </div>
          <div class="ctrl">
            <label>Marker size (px)</label
            ><input id="markerSize" type="number" min="3" max="18" value="8" />
          </div>
          <div class="ctrl">
            <label>Jitter within (m)</label
            ><input id="jitterM" type="number" min="0" step="25" value="8000" />
          </div>
          <div class="ctrl">
            <label>Show sample counts</label
            ><input id="toggleCounts" type="checkbox" checked />
          </div>
          <div class="ctrl">
            <label>Province labels</label
            ><input id="toggleProvLabels" type="checkbox" />
          </div>
          <div class="ctrl">
            <label>Country borders</label
            ><input id="toggleCountryBorders" type="checkbox" checked />
          </div>
          <div class="ctrl">
            <label>Country labels</label
            ><input id="toggleCountryLabels" type="checkbox" />
          </div>
          <div class="ctrl">
            <label>Theme</label>
            <select id="themeSelect" style="flex: 1">
              <option value="dark">Dark</option>
              <option value="light" selected>Light</option>
            </select>
          </div>

          <!-- Genetic distances -->
          <div id="treePanel">
            <section id="geneticTreeSection">
  <h2>Genetic Similarity Tree</h2>

  <div class="ctrl">
    <label>Genetic distance (.tab)</label>
    <input
      id="tabFile"
      type="file"
      accept=".tab,.tsv,text/tab-separated-values,text/plain"
    />
  </div>

  <!-- Toggle button -->
  <div class="ctrl" style="margin-top: 6px">
    <button id="treeToggle" class="btn">Show genetic tree</button>
  </div>

  <!-- Tree body (hidden by default) -->
<div id="treeBody" style="display: none">
  <div class="ctrl" id="treeZoomCtrl" style="gap: 6px; margin: 4px 0 6px 0">
    <button id="treeZoomIn" class="btn" title="Zoom in">+</button>
    <button id="treeZoomOut" class="btn" title="Zoom out">âˆ’</button>
    <span class="chip" id="treeNote" aria-live="polite"></span>
  </div>

  <!-- The tree SVG canvas -->
  <svg id="treeSVG" role="img" aria-label="Genetic similarity tree"></svg>

  <!-- Legend under the tree -->
  <div id="treeLegend" style="margin-top:6px;"></div>
</div>
</section>

          <!-- Collapsible similarity table -->
          <details id="simDetails">
            <summary style="cursor: pointer">
              Genetic similarity table (toggle)
            </summary>
            <div id="simTableWrap"></div>
          </details>

        </aside>

        <!-- Right panel: two charts + legend UNDER charts + align axis -->
        <aside id="rightPanel" aria-label="District charts">
          <div class="panel-header">
            <h2>Temporal Trends (stacked by group)</h2>
            <button
              id="hideRightPanelBtn"
              class="btn panel-hide-btn"
              type="button"
            >
              Hide charts
            </button>
          </div>

          <div class="ctrl">
            <label>Aggregate by</label>
            <select id="aggLevel" style="flex: 1">
              <option value="adm2" selected>District (ADM2)</option>
              <option value="adm1">Province (ADM1)</option>
              <option value="adm0">Country (ADM0)</option>
            </select>
          </div>

          <div class="ctrl">
            <label id="labelA">Area A</label>
            <input
              id="searchA"
              type="text"
              list="areaListA"
              placeholder="Type to search..."
              style="
                flex: 1;
                padding: 6px 8px;
                border-radius: 8px;
                border: 1px solid var(--border);
                background: var(--panel);
                color: var(--text);
              "
            />
            <datalist id="areaListA"></datalist>
            <select id="districtSelectA" style="display: none"></select>
            <!-- kept for compatibility -->
          </div>
          <svg id="chartA"></svg>

          <div class="ctrl" style="margin-top: 8px">
            <label id="labelB">Area B</label>
            <input
              id="searchB"
              type="text"
              list="areaListB"
              placeholder="Type to search..."
              style="
                flex: 1;
                padding: 6px 8px;
                border-radius: 8px;
                border: 1px solid var(--border);
                background: var(--panel);
                color: var(--text);
              "
            />
            <datalist id="areaListB"></datalist>
            <select id="districtSelectB" style="display: none"></select>
            <!-- kept for compatibility -->
          </div>
          <svg id="chartB"></svg>

          <div class="ctrl" style="margin-top: 6px">
            <label for="quarterToggle">Aggregate by quarter (3 months)</label>
            <input id="quarterToggle" type="checkbox" />
          </div>

          <div class="ctrl" style="margin-top: 6px">
            <label id="alignAxisLabel" for="alignAxisToggle"
              >Align axis (rolling 36 months)</label
            >
            <input id="alignAxisToggle" type="checkbox" checked />
          </div>

          <div style="margin-top: 6px" class="chip">
            x: month (or quarter) | y: samples (cumulative to current date)
          </div>

          <!-- Legend under charts (click to multi-select) -->
          <div
            style="
              display: flex;
              align-items: center;
              gap: 8px;
              margin-top: 10px;
            "
          >
            <strong style="font-size: 12px; opacity: 0.85">Legend</strong>
            <div class="legend-actions">
              <button id="legendShowAll">Show all</button>
              <button id="legendHideAll">Hide all</button>
              <button id="legendToggleBtn">Hide</button>
            </div>
          </div>
          <div id="legendBox" style="margin-top: 6px; line-height: 1.4"></div>
        </aside>

        <div id="toast"></div>
      </div>

      <div
        id="mapChoiceModal"
        aria-hidden="true"
        role="dialog"
        aria-modal="true"
        aria-labelledby="mapChoiceTitle"
      >
        <div class="map-choice-card">
          <h3 id="mapChoiceTitle">Choose a starting map</h3>
          <p>
            Load the bundled Eastern GMS administrative layers or continue with
            your own GeoJSON uploads.
          </p>
          <div class="map-choice-actions">
            <button type="button" class="primary" id="loadEasternGmsBtn">
              Load eastern GMS map (KH, LA, TH, VN)
            </button>
            <button type="button" class="secondary" id="loadCustomMapBtn">
              Load my own map
            </button>
          </div>
        </div>
      </div>

      <!-- Player buttons at bottom left -->
        <div id="bottomPlayerControls">
          <button class="btn timeline-btn" id="playBtn">
            <span aria-hidden="true">&#9654;</span> Play
          </button>
          <button class="btn timeline-btn" id="pauseBtn">
            <span aria-hidden="true">&#10073;&#10073;</span> Pause
          </button>
          <button class="btn timeline-btn" id="resetBtn">
            <span aria-hidden="true">&#10226;</span> Reset
          </button>
        </div>

      <!-- Timeline -->
      <footer id="timelineBar">
        <input
          id="timeSlider"
          type="range"
          min="0"
          max="100"
          step="1"
          value="0"
          disabled
        />
        <div style="display: flex; gap: 8px; align-items: center">
          <span class="pill">Date: <b id="currentDateLabel">--</b></span>
        </div>
      </footer>
    </div>

    <!-- Libs -->
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <script src="https://unpkg.com/papaparse@5.4.1/papaparse.min.js"></script>
    <script src="https://unpkg.com/@turf/turf@6.5.0/turf.min.js"></script>
    <script src="https://unpkg.com/d3@7/dist/d3.min.js"></script>

    <script>
      /* ==================== State ==================== */

      /* ===== Marker shapes + palette (theme-independent) ===== */
      // Curated, high-contrast palette (no grey colors)
      const PALETTE24 = Array.from(
        new Set([
          // ColorBrewer Set 1
          "#e41a1c",
          "#377eb8",
          "#4daf4a",
          "#984ea3",
          "#ff7f00",
          "#F0E442",
          "#a65628",
          "#f781bf",
          "#66c2a5",
          "#e7298a",
          "#E69F00",
          "#56B4E9",
          "#009E73",
          "#9C755F",
          "#E15759",
          "#EDC948",
          "#B07AA1",
          "#FF9DA7",
          "#4E79A7",
          "#fc8d62",
          "#8da0cb",
          "#a6d854",
          "#e5c494",
          "#7570b3",
        ])
      );

      // Decide which shape a (non-unclustered) cluster uses based on its index
      // 1-24: circle, 25-49: square, 50-74: diamond
      function clusterShapeByIndex(i) {
        if (i < 24) return "circle";
        if (i < 49) return "square";
        return "diamond";
      }

      // Build an SVG marker icon for Leaflet (DivIcon)
      function svgMarkerIcon({
        shape,
        color,
        size = 8,
        fillOpacity = 0.7,
        strokeOpacity = 1,
      }) {
        const s = size,
          w = size * 2 + 6,
          h = size * 2 + 6,
          cx = w / 2,
          cy = h / 2;
        let inner = "";
        if (shape === "circle") {
          inner = `<circle cx="${cx}" cy="${cy}" r="${s}" fill="${color}" fill-opacity="${fillOpacity}" stroke="${color}" stroke-opacity="${strokeOpacity}" stroke-width="2"/>`;
        } else if (shape === "square") {
          inner = `<rect x="${cx - s}" y="${cy - s}" width="${2 * s}" height="${
            2 * s
          }" fill="${color}" fill-opacity="${fillOpacity}" stroke="${color}" stroke-opacity="${strokeOpacity}" stroke-width="2"/>`;
        } else if (shape === "diamond") {
          inner = `<rect x="${cx - s}" y="${cy - s}" width="${2 * s}" height="${
            2 * s
          }" transform="rotate(45 ${cx} ${cy})" fill="${color}" fill-opacity="${fillOpacity}" stroke="${color}" stroke-opacity="${strokeOpacity}" stroke-width="2"/>`;
        } else if (shape === "triangle") {
          // upward triangle for Unclustered
          const p1 = `${cx},${cy - s}`;
          const p2 = `${cx - s},${cy + s}`;
          const p3 = `${cx + s},${cy + s}`;
          inner = `<polygon points="${p1} ${p2} ${p3}" fill="${color}" fill-opacity="${fillOpacity}" stroke="${color}" stroke-opacity="${strokeOpacity}" stroke-width="2"/>`;
        }
        const svg = `<svg xmlns="http://www.w3.org/2000/svg" width="${w}" height="${h}">${inner}</svg>`;
        return L.divIcon({
          className: "",
          html: svg,
          iconSize: [w, h],
          iconAnchor: [cx, cy],
        });
      }

      // Small SVG used in the legend swatch (global so buildLegend can call it)
      function svgLegendSwatch(shape, color) {
        const r = 7; // size of legend marker
        const w = 16,
          h = 16;
        if (shape === "circle") {
          return `<svg width="${w}" height="${h}" xmlns="http://www.w3.org/2000/svg">
      <circle cx="${w / 2}" cy="${h / 2}" r="${
            r - 1
          }" fill="${color}" stroke="${color}" stroke-width="1.5"/>
    </svg>`;
        } else if (shape === "square") {
          const s = 2 * (r - 1);
          const x = (w - s) / 2,
            y = (h - s) / 2;
          return `<svg width="${w}" height="${h}" xmlns="http://www.w3.org/2000/svg">
      <rect x="${x}" y="${y}" width="${s}" height="${s}" rx="2" ry="2"
        fill="${color}" stroke="${color}" stroke-width="1.5"/>
    </svg>`;
        } else if (shape === "diamond") {
          return `<svg width="${w}" height="${h}" xmlns="http://www.w3.org/2000/svg">
      <polygon points="${w / 2},2 ${w - 2},${h / 2} ${w / 2},${h - 2} 2,${
            h / 2
          }"
        fill="${color}" stroke="${color}" stroke-width="1.5"/>
    </svg>`;
        } else {
          // triangle
          return `<svg width="${w}" height="${h}" xmlns="http://www.w3.org/2000/svg">
      <polygon points="${w / 2},2 ${w - 2},${h - 2} 2,${h - 2}"
        fill="${color}" stroke="${color}" stroke-width="1.5"/>
    </svg>`;
        }
      }

      const DAY_MS = 86400000;

      const appState = {
        theme: "light", // Start with light theme
        data: {
          samples: [],
          clusters: new Set(),
          clusterOrder: [],
          colorScale: null,
          adm2Ids: new Set(), // district ids (GID_2)
          adm1Ids: new Set(), // province ids (GID_1)
          adm0Ids: new Set(), // country ids (NAME_0 or GID_0-like)
          idToName: new Map(), // key -> display name (for any level)
        },
        geo: {
          gidToCentroid: new Map(),
          gidToName: new Map(),
          gidToFeature: new Map(),
          districtsLayer: null,
          provincesLayer: null,
          countriesLayer: null,
          gid2_to_gid1: new Map(), // district -> province id
          gid1_to_adm0: new Map(), // province -> country id
          gid1_to_name: new Map(), // province id -> name
          adm0_to_name: new Map(), // country id -> name
        },
        charts: {
          aggLevel: "adm2", // adm2 | adm1 | adm0
          useQuarter: false,
        },
        map: {
          instance: null,
          markersLayer: null,
          countsLayer: null,
          provinceLabelsLayer: null,
          countryLabelsLayer: null,
          showCounts: true,
          markerRadius: 8,
          jitterMeters: 5000,
        },
        timeline: {
          playing: false,
          timer: null,
          minDay: null,
          maxDay: null,
          currentDay: null,
          stepDays: 7,
          stepIntervalMs: 600,
          windowDays: 30,
          lifespanDays: 180,
        },
        legend: {
          selected: new Set(),
        },
        tree: {
          zoom: null,
          zoomTransform: d3.zoomIdentity,
          data: null,
          labels: [],
          matrix: [],
        },
      };

      const dataState = appState.data;
      const geoState = appState.geo;
      const mapState = appState.map;
      const timelineState = appState.timeline;
      const legendState = appState.legend;
      const treeState = appState.tree;
      const compareState = appState.compare;

      const UNCLUSTERED_CLUSTER = { color: "#8a8f98", shape: "triangle" };

      function getClusterGlyph(clusterName) {
        if (!clusterName || clusterName === "Unclustered") {
          return UNCLUSTERED_CLUSTER;
        }
        const idx = Math.max(0, dataState.clusterOrder.indexOf(clusterName));
        const scale = dataState.colorScale;
        const color = scale
          ? scale(clusterName)
          : PALETTE24[idx % PALETTE24.length];
        return { color, shape: clusterShapeByIndex(idx) };
      }

      /* ==================== Elements ==================== */
      const dateTitle = document.getElementById("dateTitle");
      const geojsonDistrictsInput = document.getElementById(
        "geojsonDistrictsFile"
      );
      const geojsonProvincesInput = document.getElementById(
        "geojsonProvincesFile"
      );
      const geojsonCountriesInput = document.getElementById(
        "geojsonCountriesFile"
      );
      const geojsonInputGroup = document.getElementById("geojsonInputGroup");
      const easternGmsNotice = document.getElementById("easternGmsNotice");
      const csvInput = document.getElementById("csvFile");
      const tabInput = document.getElementById("tabFile");
      const playBtn = document.getElementById("playBtn");
      const pauseBtn = document.getElementById("pauseBtn");
      const resetBtn = document.getElementById("resetBtn");
      const toggleCounts = document.getElementById("toggleCounts");
      const speedDaysInput = document.getElementById("speedDays");
      const stepIntervalInput = document.getElementById("stepInterval");
      const windowDaysInput = document.getElementById("windowDays");
      const lifespanDaysInput = document.getElementById("lifespanDays");
      const markerSizeInput = document.getElementById("markerSize");
      const jitterMInput = document.getElementById("jitterM");
      const timeSlider = document.getElementById("timeSlider");
      const currentDateLabel = document.getElementById("currentDateLabel");
      const districtSelectA = document.getElementById("districtSelectA");
      const districtSelectB = document.getElementById("districtSelectB");
      const themeSelect = document.getElementById("themeSelect");
      const alignAxisToggle = document.getElementById("alignAxisToggle");
      const alignAxisLabel = document.getElementById("alignAxisLabel");
      const quarterToggle = document.getElementById("quarterToggle");
      const leftPanelEl = document.getElementById("leftPanel");
      const rightPanelEl = document.getElementById("rightPanel");
      const hideLeftPanelBtn = document.getElementById("hideLeftPanelBtn");
      const hideRightPanelBtn = document.getElementById("hideRightPanelBtn");
      const showLeftPanelBtn = document.getElementById("showLeftPanelBtn");
      const showRightPanelBtn = document.getElementById("showRightPanelBtn");
      const toggleProvLabels = document.getElementById("toggleProvLabels");
      const toggleCountryBorders = document.getElementById(
        "toggleCountryBorders"
      );
      const toggleCountryLabels = document.getElementById(
        "toggleCountryLabels"
      );
      /* Legend */
      const legendBox = document.getElementById("legendBox");
      const legendShowAllBtn = document.getElementById("legendShowAll");
      const legendHideAllBtn = document.getElementById("legendHideAll");
      const legendToggleBtn = document.getElementById("legendToggleBtn");
      const toast = document.getElementById("toast");
      const treeNote = document.getElementById("treeNote");
      const treeZoomIn = document.getElementById("treeZoomIn");
      const treeZoomOut = document.getElementById("treeZoomOut");
      const treeToggle = document.getElementById("treeToggle");
      const treeBody = document.getElementById("treeBody");
      const aggLevelSelect = document.getElementById("aggLevel");
      const labelAEl = document.getElementById("labelA");
      const labelBEl = document.getElementById("labelB");
      const searchAInput = document.getElementById("searchA");
      const searchBInput = document.getElementById("searchB");
      const areaListA = document.getElementById("areaListA");
      const areaListB = document.getElementById("areaListB");
      const mapChoiceModal = document.getElementById("mapChoiceModal");
      const loadEasternMapBtn = document.getElementById("loadEasternGmsBtn");
      const loadCustomMapBtn = document.getElementById("loadCustomMapBtn");

      const chartSelection = { A: null, B: null };
      let usingEasternGms = false;
      let mapChoicePrompted = false;
      const EASTERN_GMS_FILES = {
        adm2: "https://genre-mekong.github.io/EpiGenTracker/maps/eastern-gms/adm2.json",
        adm1: "https://genre-mekong.github.io/EpiGenTracker/maps/eastern-gms/adm1.json",
        adm0: "https://genre-mekong.github.io/EpiGenTracker/maps/eastern-gms/adm0.json",
      };
      const easternBtnDefaultLabel =
        (loadEasternMapBtn && loadEasternMapBtn.textContent.trim()) ||
        "Load eastern GMS map (KH, LA, TH, VN)";

      /* ==================== UI Helpers ==================== */
      function reflectMapSourceState() {
        if (geojsonInputGroup) {
          geojsonInputGroup.style.display = usingEasternGms ? "none" : "";
        }
        if (easternGmsNotice) {
          easternGmsNotice.style.display = usingEasternGms
            ? "inline-flex"
            : "none";
        }
      }

      function showMapChoiceModal() {
        if (!mapChoiceModal) return;
        mapChoiceModal.classList.add("show");
        mapChoiceModal.setAttribute("aria-hidden", "false");
      }

      function hideMapChoiceModal() {
        if (!mapChoiceModal) return;
        mapChoiceModal.classList.remove("show");
        mapChoiceModal.setAttribute("aria-hidden", "true");
      }

      function promptForMapChoice() {
        if (mapChoicePrompted) return;
        mapChoicePrompted = true;
        showMapChoiceModal();
      }

      reflectMapSourceState();

      if (loadCustomMapBtn) {
        loadCustomMapBtn.addEventListener("click", () => {
          usingEasternGms = false;
          reflectMapSourceState();
          hideMapChoiceModal();
        });
      }

      if (loadEasternMapBtn) {
        loadEasternMapBtn.addEventListener("click", () => {
          loadEasternGmsBundle();
        });
      }

      function showToast(msg, ms = 2800) {
        toast.textContent = msg;
        toast.style.display = "block";
        clearTimeout(showToast._t);
        showToast._t = setTimeout(() => (toast.style.display = "none"), ms);
      }

      function areaListForLevel(level) {
        // Get unique areas that actually have samples in the data
        const areasWithSamples = new Set();

        dataState.samples.forEach((sample) => {
          if (level === "adm2" && sample.gid) {
            areasWithSamples.add(sample.gid);
          } else if (level === "adm1" && sample.gid1) {
            areasWithSamples.add(sample.gid1);
          } else if (level === "adm0" && sample.adm0) {
            areasWithSamples.add(sample.adm0);
          }
        });

        // Convert to array with display names, filtering to only include areas with samples
        const areas = Array.from(areasWithSamples).map((id) => {
          const displayName =
            dataState.idToName.get(id) ||
            (level === "adm2" ? geoState.gidToName.get(id) : null) ||
            id;
          return [id, displayName];
        });

        return areas;
      }

      function populateAreaSearchLists() {
        const level = appState.charts.aggLevel;
        const items = areaListForLevel(level).sort((a, b) =>
          (a[1] || "").localeCompare(b[1] || "")
        );

        areaListA.innerHTML = items
          .map(([id, label]) => `<option value="${label}"></option>`)
          .join("");
        areaListB.innerHTML = items
          .map(([id, label]) => `<option value="${label}"></option>`)
          .join("");

        // Update labels above inputs
        labelAEl.textContent =
          level === "adm2"
            ? "District A"
            : level === "adm1"
            ? "Province A"
            : "Country A";
        labelBEl.textContent =
          level === "adm2"
            ? "District B"
            : level === "adm1"
            ? "Province B"
            : "Country B";
      }

      function nameToIdAtLevel(name, level) {
        // match either by exact label or id
        const items = areaListForLevel(level);
        const lower = String(name || "")
          .trim()
          .toLowerCase();
        const exact = items.find(
          ([id, label]) =>
            label.toLowerCase() === lower || id.toLowerCase() === lower
        );
        if (exact) return exact[0];
        // prefix match
        const pref = items.find(([id, label]) =>
          label.toLowerCase().startsWith(lower)
        );
        return pref ? pref[0] : null;
      }

      function displayNameForId(id) {
        if (!id) return "";
        return dataState.idToName.get(id) || geoState.gidToName.get(id) || id;
      }

      /* ==================== Map ==================== */
      function initMap() {
        mapState.instance = L.map("map", { zoomControl: false });
        L.control.zoom({ position: "bottomright" }).addTo(mapState.instance);
        mapState.instance.setView([15, 100], 5);
        mapState.markersLayer = L.layerGroup().addTo(mapState.instance);
        mapState.countsLayer = L.layerGroup().addTo(mapState.instance);
        mapState.provinceLabelsLayer = L.layerGroup();
        mapState.countryLabelsLayer = L.layerGroup();
      }
      initMap();

      /* ==================== Theme ==================== */
      function applyTheme(theme) {
        appState.theme = theme;
        if (theme === "light") {
          document.documentElement.classList.add("light");
        } else {
          document.documentElement.classList.remove("light");
        }
        const cs = getComputedStyle(document.documentElement);
        if (geoState.districtsLayer) {
          geoState.districtsLayer.setStyle({
            color: cs.getPropertyValue("--district-stroke").trim(),
            weight: parseFloat(cs.getPropertyValue("--district-weight")),
            fillColor: cs.getPropertyValue("--district-fill").trim(),
            fillOpacity: 1,
          });
        }
        if (geoState.provincesLayer) {
          geoState.provincesLayer.setStyle({
            color: cs.getPropertyValue("--province-stroke").trim(),
            weight: parseFloat(cs.getPropertyValue("--province-weight")),
            fillOpacity: 0,
          });
        }
        if (geoState.countriesLayer) {
          geoState.countriesLayer.setStyle({
            color: cs.getPropertyValue("--country-stroke").trim(),
            weight: parseFloat(cs.getPropertyValue("--country-weight")),
            fillOpacity: 0,
          });
        }
      }

      // Initialize theme on page load
      applyTheme("light");

      themeSelect.addEventListener("change", () =>
        applyTheme(themeSelect.value)
      );

      /* Province labels toggle */
      toggleProvLabels.addEventListener("change", () => {
        if (!mapState.provinceLabelsLayer) return;
        if (toggleProvLabels.checked) {
          if (!mapState.instance.hasLayer(mapState.provinceLabelsLayer))
            mapState.provinceLabelsLayer.addTo(mapState.instance);
        } else {
          if (mapState.instance.hasLayer(mapState.provinceLabelsLayer))
            mapState.instance.removeLayer(mapState.provinceLabelsLayer);
        }
      });

      toggleCountryLabels.addEventListener("change", () => {
        if (!mapState.countryLabelsLayer) return;
        if (toggleCountryLabels.checked) {
          if (!mapState.instance.hasLayer(mapState.countryLabelsLayer))
            mapState.countryLabelsLayer.addTo(mapState.instance);
        } else {
          if (mapState.instance.hasLayer(mapState.countryLabelsLayer))
            mapState.instance.removeLayer(mapState.countryLabelsLayer);
        }
      });

      toggleCountryBorders.addEventListener("change", () => {
        if (!geoState.countriesLayer) return;
        if (toggleCountryBorders.checked) {
          if (!mapState.instance.hasLayer(geoState.countriesLayer))
            geoState.countriesLayer.addTo(mapState.instance);
        } else {
          if (mapState.instance.hasLayer(geoState.countriesLayer))
            mapState.instance.removeLayer(geoState.countriesLayer);
        }
      });

      /* Panel toggle handlers */
      function setLeftPanelVisible(show) {
        if (!leftPanelEl || !showLeftPanelBtn || !hideLeftPanelBtn) return;
        const visible = !!show;
        leftPanelEl.classList.toggle("is-hidden", !visible);
        leftPanelEl.setAttribute("aria-hidden", visible ? "false" : "true");
        showLeftPanelBtn.hidden = visible;
        showLeftPanelBtn.style.display = visible ? "none" : "inline-flex";
        showLeftPanelBtn.setAttribute(
          "aria-expanded",
          visible ? "true" : "false"
        );
        showLeftPanelBtn.setAttribute(
          "aria-hidden",
          visible ? "true" : "false"
        );
        hideLeftPanelBtn.hidden = !visible;
        hideLeftPanelBtn.style.display = visible ? "" : "none";
      }

      function setRightPanelVisible(show) {
        if (!rightPanelEl || !showRightPanelBtn || !hideRightPanelBtn) return;
        const visible = !!show;
        rightPanelEl.classList.toggle("is-hidden", !visible);
        rightPanelEl.setAttribute("aria-hidden", visible ? "false" : "true");
        showRightPanelBtn.hidden = visible;
        showRightPanelBtn.style.display = visible ? "none" : "inline-flex";
        showRightPanelBtn.setAttribute(
          "aria-expanded",
          visible ? "true" : "false"
        );
        showRightPanelBtn.setAttribute(
          "aria-hidden",
          visible ? "true" : "false"
        );
        hideRightPanelBtn.hidden = !visible;
        hideRightPanelBtn.style.display = visible ? "" : "none";
      }

      function focusWithoutScroll(el) {
        if (!el || typeof el.focus !== "function") return;
        try {
          el.focus({ preventScroll: true });
        } catch (_) {
          el.focus();
        }
      }

      hideLeftPanelBtn.addEventListener("click", () => {
        setLeftPanelVisible(false);
        focusWithoutScroll(showLeftPanelBtn);
      });

      showLeftPanelBtn.addEventListener("click", () => {
        setLeftPanelVisible(true);
        focusWithoutScroll(hideLeftPanelBtn);
      });

      hideRightPanelBtn.addEventListener("click", () => {
        setRightPanelVisible(false);
        focusWithoutScroll(showRightPanelBtn);
      });

      showRightPanelBtn.addEventListener("click", () => {
        setRightPanelVisible(true);
        focusWithoutScroll(hideRightPanelBtn);
      });

      setLeftPanelVisible(true);
      setRightPanelVisible(true);

      /* ==================== Geo helpers ==================== */
      function normalizeKey(x) {
        return (x == null ? "" : String(x)).trim();
      }

      function findGidKey(props) {
        const keys = Object.keys(props || {});
        const candidates = [
          "GID_2",
          "GID_1",
          "GID",
          "ADM2_PCODE",
          "ADM1_PCODE",
          "PCODE",
        ];
        for (const c of candidates) {
          if (keys.includes(c)) return c;
        }
        for (const k of keys) {
          if (/GID|PCODE/i.test(k)) return k;
        }
        return null;
      }

      function findNameKey(props) {
        const keys = Object.keys(props || {});
        const candidates = [
          "AdmDiv2",
          "AdminDiv2",
          "NAME_2",
          "NAME_1",
          "ADM2_EN",
          "ADM1_EN",
          "NAME",
          "District",
          "district",
        ];
        for (const c of candidates) {
          if (keys.includes(c)) return c;
        }
        for (const k of keys) {
          if (/NAME|DIST|AdmDiv2|AdminDiv2/i.test(k)) return k;
        }
        return null;
      }

      function findProvIdKey(props) {
        const k = Object.keys(props || {});
        return (
          ["GID_1", "ADM1_PCODE", "ADM1_CODE"].find((x) => k.includes(x)) ||
          k.find((x) => /GID_1|ADM1/i.test(x)) ||
          null
        );
      }

      function findProvNameKey(props) {
        const k = Object.keys(props || {});
        return (
          ["NAME_1", "ADM1_EN", "PROVINCE", "STATE"].find((x) =>
            k.includes(x)
          ) ||
          k.find((x) => /NAME_1|ADM1/i.test(x)) ||
          null
        );
      }

      function findCountryNameKey(props) {
        const k = Object.keys(props || {});
        return (
          ["NAME_0", "ADM0_EN", "ADMIN", "COUNTRY", "SOVEREIGNT", "NAME"].find(
            (x) => k.includes(x)
          ) ||
          k.find((x) => /NAME_0|ADMIN|COUNTRY|SOVEREIGN/i.test(x)) ||
          null
        );
      }

      function findCountryId(props) {
        // many ADM2 features don't carry a stable GID_0, so we fallback to NAME_0 as id
        const k = Object.keys(props || {});
        return (
          ["GID_0", "ISO3", "ADM0_PCODE", "NAME_0", "ADMIN"].find((x) =>
            k.includes(x)
          ) ||
          k.find((x) => /GID_0|ISO3|NAME_0|ADMIN/i.test(x)) ||
          null
        );
      }

      function parseDateFlexible(s) {
        if (!s) return null;
        const t = Date.parse(s);
        if (!isNaN(t)) return new Date(t);
        const m = String(s)
          .trim()
          .match(/^(\d{1,2})[\/-](\d{1,2})[\/-](\d{2,4})$/);
        if (m) {
          const d = +m[1],
            mo = +m[2] - 1,
            y = m[3].length === 2 ? +("20" + m[3]) : +m[3];
          return new Date(Date.UTC(y, mo, d));
        }
        return null;
      }

      function fmtDateFromDayInt(dayInt) {
        const dt = new Date(dayInt * DAY_MS);
        const y = dt.getFullYear(),
          m = String(dt.getMonth() + 1).padStart(2, "0"),
          d = String(dt.getDate()).padStart(2, "0");
        return `${y}-${m}-${d}`;
      }

      /* Random point inside district with bias near base point */
      function cloneLatLngPair(src) {
        if (!src) return null;
        if (Array.isArray(src) && src.length >= 2) {
          const a = Number(src[0]);
          const b = Number(src[1]);
          if (!isNaN(a) && !isNaN(b)) return [a, b];
        }
        if (typeof src === "object") {
          if (typeof src.lat === "number" && typeof src.lng === "number") {
            return [src.lat, src.lng];
          }
          if (
            typeof src.latitude === "number" &&
            typeof src.longitude === "number"
          ) {
            return [src.latitude, src.longitude];
          }
          if (typeof src[0] === "number" && typeof src[1] === "number") {
            const a = Number(src[0]);
            const b = Number(src[1]);
            if (!isNaN(a) && !isNaN(b)) return [a, b];
          }
        }
        return null;
      }

      function largestPolygon(feature) {
        if (!feature || !feature.geometry) return null;
        const geom = feature.geometry;

        if (geom.type === "Polygon") {
          return turf.polygon(geom.coordinates);
        }
        if (geom.type === "MultiPolygon") {
          let best = null;
          let bestArea = -Infinity;
          for (const coords of geom.coordinates) {
            if (!coords || !coords.length) continue;
            const poly = turf.polygon(coords);
            const area = turf.area(poly);
            if (area > bestArea) {
              bestArea = area;
              best = poly;
            }
          }
          return best;
        }
        return null;
      }

      function visualLabelCoord(feature) {
        if (!feature) return null;

        const mainPoly = largestPolygon(feature);
        if (!mainPoly) return null;

        let point = null;

        // 1. Try polylabel first (most robust for visual center)
        if (typeof polylabel === "function") {
          try {
            const rings = mainPoly.geometry.coordinates;
            const [lng, lat] = polylabel(rings, 1.0);
            point = turf.point([lng, lat]);

            // Verify point is inside the polygon
            if (turf.booleanPointInPolygon(point, mainPoly)) {
              const coords = point.geometry.coordinates;
              return [coords[1], coords[0]]; // [lat, lng]
            }
          } catch (e) {
            console.warn("Polylabel failed, falling back:", e);
          }
        }

        // 2. Fallback to centerOfMass
        try {
          point = turf.centerOfMass(mainPoly);
          if (turf.booleanPointInPolygon(point, mainPoly)) {
            const coords = point.geometry.coordinates;
            return [coords[1], coords[0]];
          }
        } catch (e) {}

        // 3. Fallback to pointOnFeature (guaranteed to be on surface)
        try {
          point = turf.pointOnFeature(mainPoly);
          const coords = point.geometry.coordinates;
          return [coords[1], coords[0]];
        } catch (e) {}

        // 4. Fallback to centroid
        try {
          point = turf.centroid(mainPoly);
          const coords = point.geometry.coordinates;
          return [coords[1], coords[0]];
        } catch (e) {}

        // 5. Final fallback to bbox center
        try {
          point = turf.center(mainPoly);
          const coords = point.geometry.coordinates;
          return [coords[1], coords[0]];
        } catch (e) {}

        return null;
      }

      function labelCoordinateForFeature(feature) {
        return visualLabelCoord(feature);
      }

      function randomPointInPolygon(polygon) {
        let pt;
        const bbox = turf.bbox(polygon);
        do {
          pt = turf.randomPoint(1, { bbox }).features[0];
        } while (!turf.booleanPointInPolygon(pt, polygon));
        return pt.geometry.coordinates; // [lon, lat]
      }

      function randomOffsetMeters(baseLatLng, meters) {
        const base = cloneLatLngPair(baseLatLng);
        if (!base || !isFinite(meters) || meters <= 0) {
          return base;
        }
        const earthRadius = 6371000; // meters
        const distance = Math.random() * meters;
        const bearing = Math.random() * Math.PI * 2;
        const latRad = (base[0] * Math.PI) / 180;
        const lonRad = (base[1] * Math.PI) / 180;
        const angDist = distance / earthRadius;
        const sinLat = Math.sin(latRad);
        const cosLat = Math.cos(latRad);
        const sinAng = Math.sin(angDist);
        const cosAng = Math.cos(angDist);
        const newLatRad = Math.asin(
          sinLat * cosAng + cosLat * sinAng * Math.cos(bearing)
        );
        const newLonRad =
          lonRad +
          Math.atan2(
            Math.sin(bearing) * sinAng * cosLat,
            cosAng - sinLat * Math.sin(newLatRad)
          );
        return [
          (newLatRad * 180) / Math.PI,
          (((newLonRad * 180) / Math.PI + 540) % 360) - 180,
        ];
      }

      function pointNearBaseInPolygon(polygon, baseLatLng, meters) {
        const base = cloneLatLngPair(baseLatLng);
        if (!base) {
          return randomPointInPolygon(polygon);
        }
        for (let i = 0; i < 80; i++) {
          const candLatLng = randomOffsetMeters(base, meters);
          if (!candLatLng) {
            break;
          }
          if (!polygon) {
            return [candLatLng[1], candLatLng[0]];
          }
          const cand = turf.point([candLatLng[1], candLatLng[0]]);
          if (turf.booleanPointInPolygon(cand, polygon)) {
            return [candLatLng[1], candLatLng[0]];
          }
        }
        const baseLonLat = [base[1], base[0]];
        if (!polygon) {
          return baseLonLat;
        }
        if (turf.booleanPointInPolygon(turf.point(baseLonLat), polygon))
          return baseLonLat;
        return randomPointInPolygon(polygon);
      }

      function jitterWithinDistrict(gid, baseLatLng) {
        const feature = geoState.gidToFeature.get(gid);
        const base = cloneLatLngPair(baseLatLng);
        if (!feature) {
          return base || null;
        }
        if (
          base &&
          (!isFinite(mapState.jitterMeters) || mapState.jitterMeters <= 0)
        ) {
          return [base[0], base[1]];
        }
        if (
          isFinite(mapState.jitterMeters) &&
          mapState.jitterMeters > 0 &&
          base
        ) {
          const coords = pointNearBaseInPolygon(
            feature,
            base,
            mapState.jitterMeters
          );
          return [coords[1], coords[0]];
        }
        const coordsFallback = randomPointInPolygon(feature);
        return [coordsFallback[1], coordsFallback[0]];
      }

      /* ==================== Loaders ==================== */
      function loadDistrictGeoJSON(gj, { silent = false } = {}) {
        if (!gj || !Array.isArray(gj.features)) {
          if (!silent) {
            showToast("Districts GeoJSON is missing a features array.");
          }
          return;
        }

        if (geoState.districtsLayer) {
          mapState.instance.removeLayer(geoState.districtsLayer);
        }
        geoState.gidToCentroid.clear();
        geoState.gidToName.clear();
        geoState.gidToFeature.clear();

        const cs = getComputedStyle(document.documentElement);
        geoState.districtsLayer = L.geoJSON(gj, {
          style: () => ({
            color: cs.getPropertyValue("--district-stroke").trim(),
            weight: parseFloat(cs.getPropertyValue("--district-weight")),
            fillColor: cs.getPropertyValue("--district-fill").trim(),
            fillOpacity: 1,
          }),
        }).addTo(mapState.instance);

        try {
          mapState.instance.fitBounds(geoState.districtsLayer.getBounds(), {
            padding: [20, 20],
          });
        } catch (_) {}

        const proto =
          (gj.features && gj.features[0] && gj.features[0].properties) || {};
        const gidKey = findGidKey(proto);
        const nameKey = findNameKey(proto);
        const provIdGuess = findProvIdKey(proto);
        const provNameGuess = findProvNameKey(proto);
        const ctryNameGuess = findCountryNameKey(proto);
        const ctryIdGuess = findCountryId(proto);

        if (!gidKey && !silent) {
          showToast(
            "?? Could not find a GID-like property in Districts GeoJSON."
          );
        }

        gj.features.forEach((f) => {
          const props = f.properties || {};
          const gid2 = gidKey ? normalizeKey(props[gidKey]) : null;
          if (!gid2) return;

          const nm2 = nameKey ? normalizeKey(props[nameKey]) : gid2;
          geoState.gidToFeature.set(gid2, f);

          const latlng = labelCoordinateForFeature(f);
          if (latlng) {
            geoState.gidToCentroid.set(gid2, latlng);
            geoState.gidToName.set(gid2, nm2);
          }

          // hierarchy
          const gid1 = provIdGuess ? normalizeKey(props[provIdGuess]) : "";
          const nm1 = provNameGuess
            ? normalizeKey(props[provNameGuess])
            : gid1 || "";
          const adm0id = ctryIdGuess ? normalizeKey(props[ctryIdGuess]) : "";
          const adm0nm = ctryNameGuess
            ? normalizeKey(props[ctryNameGuess])
            : adm0id || "";

          if (gid1) geoState.gid2_to_gid1.set(gid2, gid1);
          if (gid1) geoState.gid1_to_name.set(gid1, nm1);
          if (adm0id) {
            if (gid1) geoState.gid1_to_adm0.set(gid1, adm0id);
            geoState.adm0_to_name.set(adm0id, adm0nm || adm0id);
          }

          // registries
          dataState.adm2Ids.add(gid2);
          if (gid1) {
            dataState.adm1Ids.add(gid1);
          }
          if (adm0id) {
            dataState.adm0Ids.add(adm0id);
          }
          dataState.idToName.set(gid2, nm2);
          if (gid1) dataState.idToName.set(gid1, nm1);
          if (adm0id) dataState.idToName.set(adm0id, adm0nm || adm0id);
        });

        if (!silent) {
          showToast(
            `Loaded ${
              gj.features?.length || 0
            } districts. You can add provinces and CSV.`
          );
        }
      }

      function loadProvinceGeoJSON(gj, { silent = false } = {}) {
        if (!gj || !Array.isArray(gj.features)) {
          if (!silent) showToast("Provinces GeoJSON is missing a features array.");
          return;
        }

        if (geoState.provincesLayer) {
          mapState.instance.removeLayer(geoState.provincesLayer);
        }
        mapState.provinceLabelsLayer.clearLayers();

        const cs = getComputedStyle(document.documentElement);
        geoState.provincesLayer = L.geoJSON(gj, {
          style: () => ({
            color: cs.getPropertyValue("--province-stroke").trim(),
            weight: parseFloat(cs.getPropertyValue("--province-weight")),
            fillOpacity: 0,
          }),
        }).addTo(mapState.instance);

        const proto =
          (gj.features && gj.features[0] && gj.features[0].properties) || {};
        const nmKey =
          ["NAME_1", "ADM1_EN", "NAME"].find((k) => proto && k in proto) ||
          Object.keys(proto || {}).find((k) => /NAME/i.test(k));
        gj.features.forEach((f) => {
          const centerLatLng = labelCoordinateForFeature(f);
          if (!centerLatLng) return;
          const label =
            nmKey && f.properties[nmKey] ? String(f.properties[nmKey]) : "";
          const lbl = L.marker(centerLatLng, {
            icon: L.divIcon({
              className: "province-label",
              html: `<span class="badge">${label}</span>`,
              iconSize: null,
              iconAnchor: [0, 0],
            }),
            interactive: false,
          });
          mapState.provinceLabelsLayer.addLayer(lbl);
        });

        if (toggleProvLabels && toggleProvLabels.checked) {
          if (!mapState.instance.hasLayer(mapState.provinceLabelsLayer))
            mapState.provinceLabelsLayer.addTo(mapState.instance);
        } else if (mapState.instance.hasLayer(mapState.provinceLabelsLayer)) {
          mapState.instance.removeLayer(mapState.provinceLabelsLayer);
        }

        if (!silent) {
          showToast(`Loaded ${gj.features?.length || 0} provinces.`);
        }
      }

      function loadCountryGeoJSON(gj, { silent = false } = {}) {
        if (!gj || !Array.isArray(gj.features)) {
          if (!silent) showToast("Countries GeoJSON is missing a features array.");
          return;
        }

        if (geoState.countriesLayer) {
          mapState.instance.removeLayer(geoState.countriesLayer);
        }
        if (mapState.countryLabelsLayer) {
          if (mapState.instance.hasLayer(mapState.countryLabelsLayer))
            mapState.instance.removeLayer(mapState.countryLabelsLayer);
          mapState.countryLabelsLayer.clearLayers();
        }

        const cs = getComputedStyle(document.documentElement);
        geoState.countriesLayer = L.geoJSON(gj, {
          style: () => ({
            color: cs.getPropertyValue("--country-stroke").trim(),
            weight: parseFloat(cs.getPropertyValue("--country-weight")),
            fillOpacity: 0,
          }),
        });

        if (toggleCountryBorders && toggleCountryBorders.checked) {
          geoState.countriesLayer.addTo(mapState.instance);
        }

        const protoC =
          (gj.features && gj.features[0] && gj.features[0].properties) || {};
        const nmKeyC =
          ["NAME_0", "ADM0_EN", "ADMIN", "COUNTRY", "NAME", "SOVEREIGNT"].find(
            (k) => protoC && k in protoC
          ) ||
          Object.keys(protoC || {}).find((k) => /name|country|admin/i.test(k));
        (gj.features || []).forEach((f) => {
          const centerLatLng = labelCoordinateForFeature(f);
          if (!centerLatLng) return;
          const label =
            nmKeyC && f.properties[nmKeyC] != null
              ? String(f.properties[nmKeyC])
              : "";
          const lbl = L.marker(centerLatLng, {
            icon: L.divIcon({
              className: "country-label",
              html: `<span class="badge">${label}</span>`,
              iconSize: null,
              iconAnchor: [0, 0],
            }),
            interactive: false,
          });
          mapState.countryLabelsLayer.addLayer(lbl);
        });

        if (toggleCountryLabels && toggleCountryLabels.checked) {
          if (!mapState.instance.hasLayer(mapState.countryLabelsLayer))
            mapState.countryLabelsLayer.addTo(mapState.instance);
        } else if (mapState.instance.hasLayer(mapState.countryLabelsLayer)) {
          mapState.instance.removeLayer(mapState.countryLabelsLayer);
        }

        try {
          mapState.instance.fitBounds(geoState.countriesLayer.getBounds(), {
            padding: [20, 20],
          });
        } catch (_) {}

        if (!silent) {
          showToast(`Loaded ${gj.features?.length || 0} countries.`);
        }
      }

      // Districts (ADM2)
      geojsonDistrictsInput.addEventListener("change", async (e) => {
        const file = e.target.files[0];
        if (!file) return;
        let gj;
        try {
          const text = await file.text();
          gj = JSON.parse(text);
        } catch (err) {
          showToast("Invalid Districts GeoJSON");
          return;
        }
        loadDistrictGeoJSON(gj);
        usingEasternGms = false;
        reflectMapSourceState();
      });

      // Provinces (ADM1) - thick border + labels
      geojsonProvincesInput.addEventListener("change", async (e) => {
        const file = e.target.files[0];
        if (!file) return;
        let gj;
        try {
          const text = await file.text();
          gj = JSON.parse(text);
        } catch (err) {
          showToast("Invalid Provinces GeoJSON");
          return;
        }
        loadProvinceGeoJSON(gj);
      });

      // Countries (ADM0) - borders + labels
      geojsonCountriesInput.addEventListener("change", async (e) => {
        const file = e.target.files[0];
        if (!file) return;
        let gj;
        try {
          const textFile = await file.text();
          gj = JSON.parse(textFile);
        } catch (err) {
          showToast("Invalid Countries GeoJSON");
          return;
        }
        loadCountryGeoJSON(gj);
      });

      async function loadEasternGmsBundle() {
        if (loadEasternMapBtn) {
          loadEasternMapBtn.disabled = true;
          loadEasternMapBtn.textContent = "Loading...";
        }
        try {
          const [adm2, adm1, adm0] = await Promise.all(
            ["adm2", "adm1", "adm0"].map((level) => {
              const url = EASTERN_GMS_FILES[level];
              if (!url) {
                throw new Error(`Missing download URL for Eastern GMS ${level}`);
              }
              return fetch(url).then((resp) => {
                if (!resp.ok) {
                  throw new Error(`Failed to load ${url} (${resp.status})`);
                }
                return resp.json();
              });
            })
          );
          loadDistrictGeoJSON(adm2, { silent: true });
          loadProvinceGeoJSON(adm1, { silent: true });
          loadCountryGeoJSON(adm0, { silent: true });
          usingEasternGms = true;
          reflectMapSourceState();
          hideMapChoiceModal();
          if (geojsonDistrictsInput) geojsonDistrictsInput.value = "";
          if (geojsonProvincesInput) geojsonProvincesInput.value = "";
          if (geojsonCountriesInput) geojsonCountriesInput.value = "";
          showToast("Eastern GMS map successfully loaded.");
        } catch (err) {
          console.error("Eastern GMS preload failed", err);
          showToast(
            "Failed to load Eastern GMS files from GitHub. Please verify the release URLs are reachable."
          );
          usingEasternGms = false;
          reflectMapSourceState();
        } finally {
          if (loadEasternMapBtn) {
            loadEasternMapBtn.disabled = false;
            loadEasternMapBtn.textContent = easternBtnDefaultLabel;
          }
        }
      }

      /* ==================== CSV loader ==================== */
      csvInput.addEventListener("change", async (e) => {
        const file = e.target.files[0];
        if (!file) return;
        Papa.parse(file, {
          header: true,
          skipEmptyLines: true,
          complete: (res) => {
            try {
              loadCSV(res.data);
            } catch (err) {
              console.error(err);
              showToast("CSV error: " + err.message);
            }
          },
          error: (err) => showToast("CSV parse failed: " + err),
        });
      });

      function loadCSV(rows) {
        dataState.samples = [];
        dataState.clusters.clear();
        dataState.clusterOrder = [];
        dataState.colorScale = null;

        const missingGIDs = new Set();
        let ok = 0;
        let bad = 0;

        for (const row of rows) {
          const gid = normalizeKey(
            row.GID_2 ||
              row.GID_1 ||
              row.AdmDiv2_GID ||
              row.AdmDiv1_GID ||
              row.ADM2_PCODE ||
              row.ADM1_PCODE ||
              row.PCODE ||
              row.gid ||
              row.GID
          );
          const date = parseDateFlexible(
            row.CollectionDate || row.date || row.Date || row.collection_date
          );
          // Accept either "Cluster" or "Group" column (case-insensitive)
const clusterRaw =
  row.Group ??
  row.group ??
  row.GROUP ??
  row.Cluster ??
  row.cluster ??
  row.CLUSTER;

const cluster =
  !clusterRaw ||
  /^(NA|null|none|uncluster|unclustered|ungrouped)$/i.test(String(clusterRaw))
    ? null
    : String(clusterRaw).trim();


          const nameFromCsv = normalizeKey(
            row.AdmDiv2 || row.AdminDiv2 || row.admdiv2 || row.adminDiv2
          );

          if (!gid || !date) {
            bad++;
            continue;
          }

          const latCSV = parseFloat(row.Latitude ?? row.latitude ?? row.lat);
          const lonCSV = parseFloat(
            row.Longitude ?? row.longitude ?? row.lon ?? row.lng
          );
          const csvHasCoords = !isNaN(latCSV) && !isNaN(lonCSV);
          const baseLatLng = csvHasCoords
            ? [latCSV, lonCSV]
            : cloneLatLngPair(geoState.gidToCentroid.get(gid));
          if (!baseLatLng) {
            missingGIDs.add(gid);
            continue;
          }

          const ll = jitterWithinDistrict(gid, baseLatLng);
          if (!ll) {
            missingGIDs.add(gid);
            continue;
          }

          const dayInt = Math.floor(date.getTime() / DAY_MS);
          const districtName =
            nameFromCsv || geoState.gidToName.get(gid) || gid;

          // hierarchy lookups for this district
          const gid1 = geoState.gid2_to_gid1.get(gid) || null;
          const adm0 = gid1 ? geoState.gid1_to_adm0.get(gid1) || null : null;

          const provName = gid1
            ? geoState.gid1_to_name.get(gid1) || gid1
            : null;
          const ctryName = adm0
            ? geoState.adm0_to_name.get(adm0) || adm0
            : null;

          dataState.samples.push({
            gid, // ADM2 id
            gid1, // ADM1 id (may be null)
            adm0, // ADM0 id (may be null)
            dayInt,
            cluster,
            baseLatLng: cloneLatLngPair(baseLatLng),
            latlng: ll,
            districtName,
            provinceName: provName || "",
            countryName: ctryName || "",
          });

          // ensure registries/names are filled even if ADM2 GeoJSON came later
          if (gid1) {
            dataState.adm1Ids.add(gid1);
            dataState.idToName.set(gid1, provName || gid1);
          }
          if (adm0) {
            dataState.adm0Ids.add(adm0);
            dataState.idToName.set(adm0, ctryName || adm0);
          }

          if (cluster) dataState.clusters.add(cluster);
          ok++;
        }

        if (ok === 0) {
          showToast("No valid rows found. Check column names and GIDs.");
          return;
        }

        const clustArr = Array.from(dataState.clusters.values()).sort();
        dataState.colorScale = d3
          .scaleOrdinal()
          .domain(clustArr)
          .range(PALETTE24);
        dataState.clusterOrder = clustArr.slice();

        legendState.selected.clear();

        timelineState.minDay = d3.min(dataState.samples, (d) => d.dayInt);
        timelineState.maxDay = d3.max(dataState.samples, (d) => d.dayInt);
        timelineState.currentDay = timelineState.minDay;

        timeSlider.min = String(timelineState.minDay);
        timeSlider.max = String(timelineState.maxDay);
        timeSlider.value = String(timelineState.currentDay);
        timeSlider.disabled = false;

        // Update area search lists with only areas that have samples
        populateAreaSearchLists();

        setPlaying(true);

        let msg = `Loaded ${ok} samples`;
        if (missingGIDs.size) {
          msg += ` | ${missingGIDs.size} GIDs not in GeoJSON`;
        }
        if (bad) {
          msg += ` | ${bad} rows skipped`;
        }
        showToast(msg, 4200);

        buildLegend();
        updateScene();
        updateTree();
      }

      /* ==================== Timeline Controls ==================== */
      function setPlaying(v) {
        timelineState.playing = v;
        if (timelineState.timer) {
          clearInterval(timelineState.timer);
          timelineState.timer = null;
        }
        if (v && timelineState.minDay != null && timelineState.maxDay != null) {
          timelineState.timer = setInterval(() => {
            if (timelineState.currentDay == null) return;
            timelineState.currentDay += timelineState.stepDays;
            if (timelineState.currentDay > timelineState.maxDay) {
              timelineState.currentDay = timelineState.minDay;
            }
            timeSlider.value = String(timelineState.currentDay);
            updateScene();
          }, timelineState.stepIntervalMs);
        }
        updateScene();
      }

      playBtn.addEventListener("click", () => setPlaying(true));
      pauseBtn.addEventListener("click", () => setPlaying(false));
      resetBtn.addEventListener("click", () => {
        if (geoState.districtsLayer) {
          mapState.instance.removeLayer(geoState.districtsLayer);
          geoState.districtsLayer = null;
        }
        if (geoState.provincesLayer) {
          mapState.instance.removeLayer(geoState.provincesLayer);
          geoState.provincesLayer = null;
        }
        if (geoState.countriesLayer) {
          mapState.instance.removeLayer(geoState.countriesLayer);
          geoState.countriesLayer = null;
        }
        if (mapState.provinceLabelsLayer) {
          mapState.provinceLabelsLayer.clearLayers();
        }
        if (mapState.countryLabelsLayer) {
          mapState.countryLabelsLayer.clearLayers();
        }
        geoState.gidToCentroid.clear();
        geoState.gidToName.clear();
        geoState.gidToFeature.clear();

        dataState.samples = [];
        dataState.clusters.clear();
        dataState.clusterOrder = [];
        dataState.colorScale = null;

        legendState.selected.clear();

        if (mapState.markersLayer) mapState.markersLayer.clearLayers();
        if (mapState.countsLayer) mapState.countsLayer.clearLayers();

        timeSlider.value = 0;
        timeSlider.disabled = true;
        timelineState.minDay = null;
        timelineState.maxDay = null;
        timelineState.currentDay = null;
        setPlaying(false);

        geojsonDistrictsInput.value = "";
        geojsonProvincesInput.value = "";
        geojsonCountriesInput.value = "";
        csvInput.value = "";
        tabInput.value = "";
        districtSelectA.innerHTML = "";
        districtSelectB.innerHTML = "";
        legendBox.innerHTML = "";

        treeState.data = null;
        treeState.zoomTransform = d3.zoomIdentity;
        d3.select("#treeSVG").selectAll("*").remove();
        if (treeBody) treeBody.style.display = "none";
        if (treeToggle) treeToggle.textContent = "Show genetic tree";
        document.getElementById("simTableWrap").innerHTML = "";
        showToast("Cleared. Load new files.");
        usingEasternGms = false;
        reflectMapSourceState();
      });

      speedDaysInput.addEventListener("change", () => {
        const parsed = Math.max(1, parseInt(speedDaysInput.value || "1", 10));
        timelineState.stepDays = parsed;
        if (timelineState.playing) setPlaying(true);
      });

      stepIntervalInput.addEventListener("change", () => {
        const parsed = Math.max(
          100,
          parseInt(stepIntervalInput.value || "600", 10)
        );
        timelineState.stepIntervalMs = parsed;
        if (timelineState.playing) setPlaying(true);
      });

      windowDaysInput.addEventListener("change", () => {
        timelineState.windowDays = Math.max(
          1,
          parseInt(windowDaysInput.value || "24", 10)
        );
        updateScene();
      });

      lifespanDaysInput.addEventListener("change", () => {
        timelineState.lifespanDays = Math.max(
          1,
          parseInt(lifespanDaysInput.value || "24", 10)
        );
        updateScene();
      });

      markerSizeInput.addEventListener("change", () => {
        mapState.markerRadius = Math.max(
          1,
          parseInt(markerSizeInput.value || "5", 10)
        );
        updateScene();
      });

      jitterMInput.addEventListener("change", () => {
        mapState.jitterMeters = Math.max(
          0,
          parseInt(jitterMInput.value || "75", 10)
        );
        reJitterAll();
        updateScene();
      });

      timeSlider.addEventListener("input", () => {
        timelineState.currentDay = parseInt(timeSlider.value, 10);
        updateScene();
      });

      window.addEventListener("keydown", (e) => {
        if (e.code === "Space") {
          e.preventDefault();
          setPlaying(!timelineState.playing);
        }
      });

      toggleCounts.addEventListener("change", () => {
        mapState.showCounts = toggleCounts.checked;
        if (mapState.showCounts) {
          if (
            mapState.countsLayer &&
            !mapState.instance.hasLayer(mapState.countsLayer)
          ) {
            mapState.countsLayer.addTo(mapState.instance);
          }
        } else if (
          mapState.countsLayer &&
          mapState.instance.hasLayer(mapState.countsLayer)
        ) {
          mapState.instance.removeLayer(mapState.countsLayer);
        }
        updateScene();
      });

      /* ==================== Legend (under charts) ==================== */
      legendShowAllBtn.addEventListener("click", () => {
        legendState.selected.clear();
        updateScene();
        updateCharts();
        refreshLegendActive();
        updateTree();
      });

      legendHideAllBtn.addEventListener("click", () => {
        legendState.selected = new Set(["__NONE__"]);
        updateScene();
        updateCharts();
        refreshLegendActive();
        updateTree();
      });

      legendToggleBtn.addEventListener("click", () => {
        const isHidden = legendBox.style.display === "none";
        legendBox.style.display = isHidden ? "block" : "none";
        legendToggleBtn.textContent = isHidden ? "Hide" : "Show";
      });

      function buildLegend() {
        if (!legendBox) return;
        legendBox.innerHTML = "";
        legendBox.style.display = "block";
        if (legendToggleBtn) legendToggleBtn.textContent = "Hide";
        const clustersList = Array.from(
          new Set(dataState.samples.map((s) => s.cluster || "Unclustered"))
        ).sort();
        clustersList.forEach((c) => {
          const row = document.createElement("div");
          row.className = "legend-row";
          row.dataset.key = c;
          const sw = document.createElement("span");
          sw.className = "swatch";
          const glyph = getClusterGlyph(c);
          sw.innerHTML = svgLegendSwatch(glyph.shape, glyph.color);

          const lbl = document.createElement("span");
          lbl.textContent = c;
          row.appendChild(sw);
          row.appendChild(lbl);
          row.addEventListener("click", () => {
            if (legendState.selected.has("__NONE__"))
              legendState.selected.delete("__NONE__");
            if (legendState.selected.has(c)) {
              legendState.selected.delete(c);
            } else {
              legendState.selected.add(c);
            }
            updateScene();
            updateCharts();
            refreshLegendActive();
            updateTree();
          });
          legendBox.appendChild(row);
        });
        refreshLegendActive();
      }

      function refreshLegendActive() {
        const rows = legendBox.querySelectorAll(".legend-row");
        rows.forEach((r) => {
          const key = r.dataset.key;
          const active =
            legendState.selected.size === 0
              ? true
              : legendState.selected.has("__NONE__")
              ? false
              : legendState.selected.has(key);
          r.classList.toggle("inactive", !active);
        });
      }

      function clusterIsActive(name) {
        if (legendState.selected.size === 0) return true;
        if (legendState.selected.has("__NONE__")) return false;
        return legendState.selected.has(name || "Unclustered");
      }

      /* ==================== Re-jitter ==================== */
      function reJitterAll() {
        dataState.samples.forEach((s) => {
          let baseForBias = cloneLatLngPair(s.baseLatLng);
          if (!baseForBias) {
            const centroid = cloneLatLngPair(geoState.gidToCentroid.get(s.gid));
            if (centroid) {
              baseForBias = centroid;
            } else if (Array.isArray(s.latlng) && s.latlng.length >= 2) {
              baseForBias = [s.latlng[0], s.latlng[1]];
            }
            if (baseForBias) {
              s.baseLatLng = [baseForBias[0], baseForBias[1]];
            }
          }
          if (!baseForBias) {
            return;
          }
          s.latlng = jitterWithinDistrict(s.gid, baseForBias);
        });
      }

      /* ==================== Scene & Charts ==================== */
      function updateScene() {
        if (timelineState.currentDay == null) return;
        const lookbackDays = Math.max(
          timelineState.windowDays,
          timelineState.lifespanDays
        );
        const startDay = timelineState.currentDay - (lookbackDays - 1);
        const dateStr = fmtDateFromDayInt(timelineState.currentDay);
        currentDateLabel.textContent = dateStr;
        dateTitle.textContent = dateStr;

        const inWindow = dataState.samples.filter(
          (s) => s.dayInt >= startDay && s.dayInt <= timelineState.currentDay
        );
        const visibleLife = inWindow.filter(
          (s) =>
            timelineState.currentDay - s.dayInt <=
            timelineState.lifespanDays - 1
        );

        if (mapState.markersLayer) {
          mapState.markersLayer.clearLayers();
        }
        const isAll = legendState.selected.size === 0;
        const isNone = legendState.selected.has("__NONE__");

        visibleLife.forEach((s) => {
          const key = s.cluster || "Unclustered";
          const glyph = getClusterGlyph(key);
          const ageDays = timelineState.currentDay - s.dayInt;
          const baseAlpha = Math.max(
            0.25,
            1 - ageDays / Math.max(1, timelineState.lifespanDays)
          );
          const active = isAll
            ? true
            : !isNone && legendState.selected.has(key);

          const icon = svgMarkerIcon({
            shape: glyph.shape,
            color: glyph.color,
            size: mapState.markerRadius,
            fillOpacity: active ? 0.35 + 0.55 * baseAlpha : 0,
            strokeOpacity: active ? 1 : 0.7,
          });

          L.marker(s.latlng, { icon })
            .bindTooltip(
              `${geoState.gidToName.get(s.gid) || s.gid}<br><strong>${
                s.cluster || "Unclustered"
              }</strong><br>${fmtDateFromDayInt(s.dayInt)}`
            )
            .addTo(mapState.markersLayer);
        });

        if (mapState.countsLayer) {
          mapState.countsLayer.clearLayers();
        }
        if (mapState.showCounts && mapState.countsLayer) {
          const counts = d3.rollup(
            visibleLife,
            (v) => v.length,
            (s) => s.gid
          );
          for (const [gid, count] of counts) {
            const center = geoState.gidToCentroid.get(gid);
            if (!center) continue;
            const icon = L.divIcon({
              className: "",
              html: `<div class="count-badge">${count}</div>`,
            });
            L.marker(center, { icon, interactive: false }).addTo(
              mapState.countsLayer
            );
          }
        }

        updateCharts();
      }

      /* Charts */
      const CH_W = 380,
        CH_H = 180,
        M = { top: 16, right: 10, bottom: 60, left: 40 };

      function makeChart(svgSel) {
        const el = d3.select(svgSel);
        el.attr("width", CH_W).attr("height", CH_H);
        const g = el
          .append("g")
          .attr("transform", `translate(${M.left},${M.top})`);
        return {
          g,
          gXAxis: g
            .append("g")
            .attr("transform", `translate(0,${CH_H - M.top - M.bottom})`),
          gYAxis: g.append("g"),
          gBars: g.append("g"),
          innerW: CH_W - M.left - M.right,
          innerH: CH_H - M.top - M.bottom,
        };
      }

      const CA = makeChart("#chartA");
      const CB = makeChart("#chartB");

      districtSelectA.addEventListener("change", updateCharts);
      districtSelectB.addEventListener("change", updateCharts);
      alignAxisToggle.addEventListener("change", updateCharts);
      if (quarterToggle) {
        quarterToggle.checked = appState.charts.useQuarter;
        quarterToggle.addEventListener("change", () => {
          appState.charts.useQuarter = quarterToggle.checked;
          updateAlignAxisLabelText();
          updateCharts();
        });
      }
      updateAlignAxisLabelText();

      function monthKeyFromDayInt(dayInt) {
        const dt = new Date(dayInt * DAY_MS);
        return `${dt.getFullYear()}-${String(dt.getMonth() + 1).padStart(
          2,
          "0"
        )}`;
      }

      function quarterKeyFromDayInt(dayInt) {
        const dt = new Date(dayInt * DAY_MS);
        const quarter = Math.floor(dt.getUTCMonth() / 3) + 1;
        return `${dt.getUTCFullYear()}-Q${quarter}`;
      }

      function monthKeysWindow(endDayInt, n = 36) {
        const end = new Date(endDayInt * DAY_MS);
        const endY = end.getUTCFullYear();
        const endM = end.getUTCMonth();
        const keys = [];
        for (let i = n - 1; i >= 0; i--) {
          const d = new Date(Date.UTC(endY, endM - i, 1));
          keys.push(
            `${d.getUTCFullYear()}-${String(d.getUTCMonth() + 1).padStart(
              2,
              "0"
            )}`
          );
        }
        return keys;
      }

      function quarterKeysWindow(endDayInt, n = 24) {
        const end = new Date(endDayInt * DAY_MS);
        let year = end.getUTCFullYear();
        let quarter = Math.floor(end.getUTCMonth() / 3) + 1;
        const keys = [];
        for (let i = 0; i < n; i++) {
          keys.push(`${year}-Q${quarter}`);
          quarter -= 1;
          if (quarter === 0) {
            quarter = 4;
            year -= 1;
            if (year < 0) break;
          }
        }
        return keys.reverse();
      }

      function formatTimeBucketLabel(value) {
        if (!value) return "";
        if (value.includes("-Q")) {
          const [year, quarter] = value.split("-Q");
          return `Q${quarter}-${year}`;
        }
        return value;
      }

      function updateAlignAxisLabelText() {
        if (!alignAxisLabel) return;
        alignAxisLabel.textContent = appState.charts.useQuarter
          ? "Align axis (rolling 24 quarters)"
          : "Align axis (rolling 36 months)";
      }

      function renderChartInto(
        groups,
        selectedAreaId,
        titleText,
        monthsDomain = null
      ) {
        const { g, gXAxis, gYAxis, gBars, innerW, innerH } = groups;
        gBars.selectAll("*").remove();
        gXAxis.selectAll("*").remove();
        gYAxis.selectAll("*").remove();
        if (!selectedAreaId) return;

        const upto = timelineState.currentDay ?? timelineState.maxDay ?? 0;
        const level = appState.charts.aggLevel;

        // filter samples by chosen level
        let rowsAll;
        if (level === "adm2") {
          rowsAll = dataState.samples.filter(
            (s) => s.gid === selectedAreaId && s.dayInt <= upto
          );
        } else if (level === "adm1") {
          rowsAll = dataState.samples.filter(
            (s) => s.gid1 === selectedAreaId && s.dayInt <= upto
          );
        } else {
          rowsAll = dataState.samples.filter(
            (s) => s.adm0 === selectedAreaId && s.dayInt <= upto
          );
        }

        const periodKeyFn = appState.charts.useQuarter
          ? quarterKeyFromDayInt
          : monthKeyFromDayInt;
        const months =
          monthsDomain && monthsDomain.length
            ? monthsDomain.slice()
            : Array.from(
                new Set(rowsAll.map((r) => periodKeyFn(r.dayInt)))
              ).sort();

        const clusterNames = Array.from(
          new Set(rowsAll.map((r) => r.cluster || "Unclustered"))
        ).sort();

        const monthToCounts = new Map(
          months.map((m) => [
            m,
            Object.fromEntries(clusterNames.map((c) => [c, 0])),
          ])
        );
        rowsAll.forEach((r) => {
          const mk = periodKeyFn(r.dayInt);
          if (!monthToCounts.has(mk)) {
            if (!monthsDomain) {
              monthToCounts.set(
                mk,
                Object.fromEntries(clusterNames.map((c) => [c, 0]))
              );
              months.push(mk);
            } else return;
          }
          monthToCounts.get(mk)[r.cluster || "Unclustered"] += 1;
        });
        months.sort();
        const data = months.map((m) => ({
          bucket: m,
          ...(monthToCounts.get(m) || {}),
        }));

        const x = d3.scaleBand().domain(months).range([0, innerW]).padding(0.1);
        const yMax = data.length
          ? d3.max(data, (d) => d3.sum(clusterNames, (c) => d[c] || 0))
          : 1;
        const y = d3.scaleLinear().domain([0, yMax]).nice().range([innerH, 0]);

        const color = (name) => getClusterGlyph(name).color;
        const stack = d3.stack().keys(clusterNames);
        const series = stack(data);

        const fadeVal = parseFloat(
          getComputedStyle(document.documentElement).getPropertyValue("--fade")
        );
        const layerG = gBars
          .selectAll("g.layer")
          .data(series, (d) => d.key)
          .join((enter) => enter.append("g").attr("class", "layer"))
          .attr("fill", (d) => color(d.key))
          .attr("opacity", (d) => {
            if (legendState.selected.size === 0) return 1;
            if (legendState.selected.has("__NONE__")) return 0.05;
            return legendState.selected.has(d.key) ? 1 : fadeVal;
          });

        layerG
          .selectAll("rect")
              .data((d) =>
                d.map((v) => ({
                  key: d.key,
                  bucket: v.data.bucket,
                  y0: v[0],
                  y1: v[1],
                }))
              )
              .join("rect")
              .attr("x", (d) => x(d.bucket))
          .attr("y", (d) => y(d.y1))
          .attr("height", (d) => Math.max(0, y(d.y0) - y(d.y1)))
          .attr("width", x.bandwidth());

        gXAxis.call(
          d3.axisBottom(x).tickValues(months).tickFormat(formatTimeBucketLabel)
        );
        gXAxis
          .selectAll("text")
          .attr("transform", "rotate(-90)")
          .style("text-anchor", "end")
          .attr("dx", "-8px")
          .attr("dy", "-4px");
        gYAxis.call(d3.axisLeft(y).ticks(4));

        g.selectAll("text.title")
          .data([0])
          .join("text")
          .attr("class", "title")
          .attr("x", 0)
          .attr("y", -6)
          .attr(
            "fill",
            getComputedStyle(document.documentElement).getPropertyValue(
              "--muted"
            )
          )
          .attr("font-size", "12px")
          .text(
            titleText +
              " - to " +
              fmtDateFromDayInt(
                timelineState.currentDay ?? timelineState.minDay ?? upto
              )
          );
      }

      /* ==================== Charts update wrapper ==================== */
      function updateCharts() {
        const aligned = alignAxisToggle.checked;
        const alignedDomain =
          aligned && timelineState.currentDay != null
            ? appState.charts.useQuarter
              ? quarterKeysWindow(timelineState.currentDay, 24)
              : monthKeysWindow(timelineState.currentDay, 36)
            : null;

        const idA = chartSelection.A;
        const idB = chartSelection.B;

        const titleA = displayNameForId(idA);
        const titleB = displayNameForId(idB);

        renderChartInto(CA, idA, titleA, alignedDomain);
        renderChartInto(CB, idB, titleB, alignedDomain);
      }

      /* ==================== Genetic distances (.tab) - NJ tree ==================== */
      tabInput.addEventListener("change", async (e) => {
        const file = e.target.files[0];
        if (!file) return;
        const text = await file.text();
        treeState.data = parseDistanceTab(text);
        if (!treeState.data) {
          showToast(
            'Could not parse genetic distance .tab (needs "Cluster" header and square matrix).'
          );
          return;
        }
        showToast(
          `Loaded genetic distances for ${treeState.data.labels.length} clusters.`
        );
        updateTree();
      });

      function parseDistanceTab(text) {
        const rows = text
          .replace(/^\uFEFF/, "")
          .trim()
          .split(/\r?\n/)
          .map((r) => r.split(/\t/).map((s) => String(s || "").trim()));
        if (rows.length < 2) return null;
        const header = rows[0];
        const labels = header
          .slice(1)
          .map((s) => s.replace(/^"+|"+$/g, "").trim());
        if (labels.length < 2) return null;

        const n = labels.length;
        const indexByLabel = new Map(labels.map((l, i) => [l, i]));
        const M = Array.from({ length: n }, () => Array(n).fill(0));

        for (let r = 1; r < rows.length; r++) {
          const row = rows[r];
          if (!row.length) continue;
          const lab = (row[0] || "").replace(/^"+|"+$/g, "").trim();
          if (!indexByLabel.has(lab)) continue;
          const i = indexByLabel.get(lab);
          for (let c = 1; c <= n; c++) {
            const cell = (row[c] ?? "").replace(",", ".");
            const v = parseFloat(cell);
            if (!isNaN(v)) M[i][c - 1] = v;
          }
        }

        // Symmetrize, clamp [0,1], diag=0
        for (let i = 0; i < n; i++) {
          for (let j = 0; j < n; j++) {
            if (i === j) {
              M[i][j] = 0;
              continue;
            }
            const a = M[i][j],
              b = M[j][i];
            let v =
              isFinite(a) && isFinite(b)
                ? (a + b) / 2
                : isFinite(a)
                ? a
                : isFinite(b)
                ? b
                : 1;
            M[i][j] = Math.max(0, Math.min(1, v));
          }
        }
        return { labels, matrix: M };
      }

      /* Neighbor-Joining to adjacency (unrooted); also returns the ID of the final join node */
      function buildNJAdjacency(subsetLabels) {
        const all = treeState.data.labels;
        const idx = subsetLabels.map((l) => all.indexOf(l));
        if (idx.some((i) => i < 0)) return null;

        // Working subset distance matrix
        let D = idx.map((i) => idx.map((j) => treeState.data.matrix[i][j]));
        let ids = subsetLabels.slice();

        const edges = [];
        let internalCounter = 0;

        function rowSums(mat) {
          const n = mat.length,
            r = Array(n).fill(0);
          for (let i = 0; i < n; i++)
            for (let j = 0; j < n; j++) r[i] += mat[i][j];
          return r;
        }

        while (ids.length > 2) {
          const n = D.length;
          const R = rowSums(D);

          let bi = 0,
            bj = 1,
            best = Infinity;
          for (let i = 0; i < n; i++) {
            for (let j = i + 1; j < n; j++) {
              const Q = (n - 2) * D[i][j] - R[i] - R[j];
              if (Q < best) {
                best = Q;
                bi = i;
                bj = j;
              }
            }
          }

          const Dij = D[bi][bj];
          const delta = (R[bi] - R[bj]) / (n - 2);
          let Li = Math.max(0, 0.5 * (Dij + delta));
          let Lj = Math.max(0, Dij - Li);

          const newId = `NJ#${++internalCounter}`;
          edges.push([newId, ids[bi], Li]);
          edges.push([newId, ids[bj], Lj]);

          // New distances to remaining taxa
          const newRow = [];
          for (let k = 0; k < n; k++) {
            if (k === bi || k === bj) {
              newRow.push(0);
              continue;
            }
            const Duk = Math.max(
              0,
              Math.min(1, 0.5 * (D[bi][k] + D[bj][k] - Dij))
            );
            newRow.push(Duk);
          }

          const keep = [];
          for (let k = 0; k < n; k++) if (k !== bi && k !== bj) keep.push(k);
          const Dnext = Array.from({ length: keep.length + 1 }, () =>
            Array(keep.length + 1).fill(0)
          );
          for (let a = 0; a < keep.length; a++)
            for (let b = 0; b < keep.length; b++)
              Dnext[a][b] = D[keep[a]][keep[b]];
          const u = keep.length;
          for (let a = 0; a < keep.length; a++) {
            Dnext[a][u] = newRow[keep[a]];
            Dnext[u][a] = newRow[keep[a]];
          }
          D = Dnext;

          const nextIds = keep.map((k) => ids[k]);
          nextIds.push(newId);
          ids = nextIds;
        }

        // Final join (two nodes remain)
        const Dij2 = D[0][1];
        const a = ids[0],
          b = ids[1];
        const finalRoot = `NJ#root`;
        edges.push([finalRoot, a, Math.max(0, Dij2 / 2)]);
        edges.push([finalRoot, b, Math.max(0, Dij2 / 2)]);

        // Build adjacency
        const adj = new Map();
        function addEdge(u, v, len) {
          if (!adj.has(u)) adj.set(u, []);
          if (!adj.has(v)) adj.set(v, []);
          adj.get(u).push({ id: v, w: len });
          adj.get(v).push({ id: u, w: len });
        }
        edges.forEach(([u, v, w]) => addEdge(u, v, w));
        return { adj, rootId: finalRoot };
      }

      /* Convert rooted adjacency into a d3-friendly tree with edgeLength on each child node */
      function buildDirectedTree(adjacency, rootId) {
        function dfs(u, parent = null) {
          const children = [];
          for (const { id: v, w } of adjacency.get(u)) {
            if (v === parent) continue;
            const child = dfs(v, u);
            child.edgeLength = w;
            children.push(child);
          }
          return { name: u, children };
        }
        return dfs(rootId, null);
      }

      /* Draw rectangular phylogram scaled by cumulative branch length. */
      function updateTree() {
        const svg = d3.select("#treeSVG");
        const note = treeNote;
        svg.selectAll("*").remove();
        note.textContent = "";

        if (!treeState.data) {
          note.textContent =
            "Load a genetic distance .tab to display the tree.";
          return;
        }

        // Selection: legend subset or all clusters from CSV; omit "Unclustered"
        let sel =
          legendState.selected.size && !legendState.selected.has("__NONE__")
            ? Array.from(legendState.selected)
            : Array.from(dataState.clusters);
        sel = sel.filter((c) => c && c !== "Unclustered");

        // Keep order consistent with matrix header & keep only present labels
        const present = treeState.data.labels.filter((l) => sel.includes(l));
        if (present.length < 2) {
          note.textContent = sel.length
            ? "Not enough clusters (need >= 2 that exist in the matrix)."
            : "No clusters selected.";
          document.getElementById("simTableWrap").innerHTML = "";
          return;
        }

        // Build NJ adjacency and use its final join as root (no midpoint rooting)
        const nj = buildNJAdjacency(present);
        if (!nj) {
          note.textContent = "Failed to build NJ tree for the selection.";
          return;
        }
        const { adj, rootId } = nj;

        const tree = buildDirectedTree(adj, rootId);
        const root = d3.hierarchy(tree, (d) =>
          d.children && d.children.length ? d.children : null
        );

        // cumulative length from root
        root.each((n) => {
          n.data.cum = n.parent
            ? (n.parent.data.cum || 0) + (n.data.edgeLength || 0)
            : 0;
        });
        const maxCum = d3.max(root.descendants(), (d) => d.data.cum || 0) || 1;

        // Canvas and groups (extra right padding for labels so tips never go out of view)
        const W = document.getElementById("treeSVG").clientWidth || 320;
        const H = document.getElementById("treeSVG").clientHeight || 300;
        const labelPad = 110; // space for text at the right
        const margin = { top: 10, right: labelPad, bottom: 10, left: 60 };
        const innerW = W - margin.left - margin.right;
        const innerH = H - margin.top - margin.bottom;

        const pane = svg.append("g").attr("class", "tree-pane"); // this group will be panned/zoomed
        const g = pane
          .append("g")
          .attr("transform", `translate(${margin.left},${margin.top})`);

        // init or rebind zoom (drag to pan, wheel/pinch to zoom)
        if (!treeState.zoom) {
          treeState.zoom = d3
            .zoom()
            .scaleExtent([0.6, 6])
            .on("zoom", (ev) => {
              d3.select("#treeSVG g.tree-pane").attr("transform", ev.transform);
              treeState.zoomTransform = ev.transform;
            });
        }
        svg
          .call(treeState.zoom) // attach behavior
          .call(treeState.zoom.transform, treeState.zoomTransform); // restore previous view

        // vertical positions via d3.cluster; horizontal = cumulative length
        d3.cluster().size([innerH, 1])(root);
        const x = d3.scaleLinear().domain([0, maxCum]).range([0, innerW]);
        root.each((n) => {
          n.y = x(n.data.cum || 0);
        });

        // Links
        const link = d3
          .linkHorizontal()
          .x((d) => d.y)
          .y((d) => d.x);
        g.selectAll("path.link")
          .data(root.links())
          .join("path")
          .attr("class", "link")
          .attr("fill", "none")
          .attr("stroke", "var(--muted)")
          .attr("stroke-width", 2)
          .attr("d", link);

        // Nodes: leaves with cluster colours; internal small gray dots
        const leaves = root.leaves();
        // Leaves: shape consistent with legend
        const leafSel = g
          .selectAll(".leaf-shape")
          .data(leaves)
          .join("g")
          .attr("class", "leaf-shape")
          .attr("transform", (d) => `translate(${d.y},${d.x})`);

        leafSel.each(function (d) {
          const key = d.data.name;
          const glyph = getClusterGlyph(key);

          const sel = d3.select(this);
          sel.selectAll("*").remove();

          if (glyph.shape === "circle") {
            sel.append("circle").attr("r", 5).attr("fill", glyph.color);
          } else if (glyph.shape === "square") {
            sel
              .append("rect")
              .attr("x", -5)
              .attr("y", -5)
              .attr("width", 10)
              .attr("height", 10)
              .attr("fill", glyph.color);
          } else if (glyph.shape === "diamond") {
            sel
              .append("rect")
              .attr("x", -5)
              .attr("y", -5)
              .attr("width", 10)
              .attr("height", 10)
              .attr("transform", "rotate(45)")
              .attr("fill", glyph.color);
          } else if (glyph.shape === "triangle") {
            sel
              .append("polygon")
              .attr("points", "0,-6 6,6 -6,6")
              .attr("fill", glyph.color);
          }
        });

        // Labels
        g.selectAll("text.leaf")
          .data(leaves)
          .join("text")
          .attr("x", (d) => d.y + 8)
          .attr("y", (d) => d.x + 4)
          .style("fill", "var(--text)")
          .style("font-size", "12px")
          .text((d) => d.data.name);

        const internals = root
          .descendants()
          .filter(
            (d) =>
              d.children && d.children.length && !present.includes(d.data.name)
          );
        g.selectAll("circle.internal")
          .data(internals)
          .join("circle")
          .attr("class", "internal")
          .attr("cx", (d) => d.y)
          .attr("cy", (d) => d.x)
          .attr("r", 2.5)
          .attr("fill", "#9ca3af");

        // Legend
        const legend = d3.select("#treeLegend");
        legend.html(
          `<div class="chip">Tips colored by cluster; vertical spacing is arbitrary; horizontal = cumulative branch length.</div>`
        );

        // Similarity table for selected clusters
        renderSimilarityTable(present);
      }

      /* ---------- Similarity table ---------- */
      function renderSimilarityTable(selectedLabels) {
        if (!treeState.data) {
          document.getElementById("simTableWrap").innerHTML = "";
          return;
        }
        const idx = selectedLabels.map((l) => treeState.data.labels.indexOf(l));
        const rows = [];
        for (let i = 0; i < idx.length; i++) {
          for (let j = i + 1; j < idx.length; j++) {
            const a = selectedLabels[i],
              b = selectedLabels[j];
            const d = treeState.data.matrix[idx[i]][idx[j]];
            const sim = Math.max(0, Math.min(1, 1 - d)); // 0..1
            rows.push({ cluster_a: a, cluster_b: b, similarity: sim });
          }
        }
        rows.sort((r1, r2) => r2.similarity - r1.similarity);

        const wrap = document.getElementById("simTableWrap");
        if (rows.length === 0) {
          wrap.innerHTML =
            '<div style="font-size:12px; color:var(--muted)">No pairs.</div>';
          return;
        }

        const table = document.createElement("table");
        table.id = "simTable";
        table.innerHTML = `
    <thead><tr><th>cluster_a</th><th>cluster_b</th><th>genetic similarity</th></tr></thead>
    <tbody>
      ${rows
        .map(
          (r) =>
            `<tr><td>${r.cluster_a}</td><td>${r.cluster_b}</td><td>${(
              r.similarity * 100
            ).toFixed(1)}%</td></tr>`
        )
        .join("")}
    </tbody>`;
        wrap.innerHTML = "";
        wrap.appendChild(table);
      }

      /* ==================== Genetic Tree Toggle ==================== */
      treeToggle.addEventListener("click", () => {
        const show =
          treeBody.style.display === "none" || treeBody.style.display === "";
        treeBody.style.display = show ? "block" : "none";
        treeToggle.textContent = show
          ? "Hide genetic tree"
          : "Show genetic tree";
      });

      /* Zoom buttons for genetic tree */
      treeZoomIn.addEventListener("click", () => {
        if (!treeState.zoom) return;
        const svgEl = document.getElementById("treeSVG");
        const STEP = 1.2;
        const p = [svgEl.clientWidth / 2, svgEl.clientHeight / 2];
        d3.select(svgEl)
          .transition()
          .duration(160)
          .call(treeState.zoom.scaleBy, STEP, p);
      });

      treeZoomOut.addEventListener("click", () => {
        if (!treeState.zoom) return;
        const svgEl = document.getElementById("treeSVG");
        const STEP = 1.2;
        const p = [svgEl.clientWidth / 2, svgEl.clientHeight / 2];
        d3.select(svgEl)
          .transition()
          .duration(160)
          .call(treeState.zoom.scaleBy, 1 / STEP, p);
      });


      /* ==================== Search Input Handlers ==================== */
      searchAInput.addEventListener("change", () => {
        const id = nameToIdAtLevel(
          searchAInput.value,
          appState.charts.aggLevel
        );
        if (id) {
          chartSelection.A = id;
          updateCharts();
        }
      });

      searchBInput.addEventListener("change", () => {
        const id = nameToIdAtLevel(
          searchBInput.value,
          appState.charts.aggLevel
        );
        if (id) {
          chartSelection.B = id;
          updateCharts();
        }
      });

      /* ==================== Aggregation Level Handler ==================== */
      aggLevelSelect.addEventListener("change", () => {
        appState.charts.aggLevel = aggLevelSelect.value;
        populateAreaSearchLists();
        chartSelection.A = chartSelection.B = null;
        searchAInput.value = "";
        searchBInput.value = "";
        updateCharts();
        if (typeof updateCompareAreaList === 'function') updateCompareAreaList();
      });

      // Initialize the page
      setLeftPanelVisible(true);
      setRightPanelVisible(true);
      applyTheme("light");
    </script>
    <!-- Onboarding containers -->
<div class="tour-backdrop" id="tour-backdrop"></div>
<div class="tour-spotlight" id="tour-spotlight"></div>
<div class="tour-tooltip" id="tour-tooltip" role="dialog" aria-live="polite"></div>
<!-- Help / Replay Tutorial (floating ?) -->
<button id="help-replay-tutorial" class="help-fab" type="button" title="Tutorial">?</button>
<script>
(function(){
  // ----- CONFIG: 6-step tutorial -----
  const steps = [
    {
      id: 'welcome',
      selector: null, // centered modal, no target
      title: ' <img class="tour-logo" src="https://genre-mekong.github.io/EpiGenTracker/assets/images/GenReMekongLogo.jpg" alt="GenRe-Mekong logo">',
      html: `
      <div class="tour-heading">
    <span><strong> Welcome to EpiGenTracker> </strong> ðŸ‘‹</span>
  </div>
  <p>_________________________________________________________________________</p>
  <p>This app allows you to explore data interactively across <b>space</b>, <b>time</b>, and <b>category</b>.</p>
  <p>You can walk through a quick guide (~1 minute) or skip and start exploring.</p>
  <p>_________________________________________________________________________</p>
`,

      primary: 'Start tutorial',
      allowSkip: true,
      placement: 'center'
    },
    {
      id: 'load',
      selector: '#DataSection',
      title: 'Load your data ðŸ“‚',
      html: `
        <p>Upload your <b>GeoJSON maps</b> and <b>sample data</b> to begin. </p>
        <p> </p>
        <p>Essential: </p>
        <p> â€¢ ADM2.geojson </p>
        <p> â€¢ Sample.csv </p> 

      `,
      primary: 'Next',
      placement: 'right'
    },
    {
      id: 'time-map',
      selector: '#timelineBar',
      title: 'Explore in time and space ðŸ—ºï¸',
      html: `
        <p>Drag or click the <b>timeline</b> to move through dates. The map updates as you go.</p>
      `,
      primary: 'Next',
      placement: 'top'
    },
    {
      id: 'trends',
      selector: '#rightPanel',
      title: 'Sample trends by group ðŸ“Š',
      html: `
        <p>Select an area in the box aggregate by administration level. </p> 
        <p> Compare <b>Temporal trends</b> between areas, stacked counts by group.</p>

      `,
      primary: 'Next',
      placement: 'left'
    },
    {
      id: 'tree',
      selector: '#geneticTreeSection',
      title: ' (Optional) Clusters & genetic tree ðŸ§¬',
      html: `
  <p>You can load a distance matrix to see the <b>genetic similarity tree</b>.</p>

`,
      primary: 'Next',
      placement: 'right'
    },
    {
      id: 'goodbye',
      selector: null,
      title: 'Youâ€™re ready ðŸŽ‰',
      html: `
        <p>Explore your data freely â€” you can replay this tutorial anytime from the <b>?</b> button.</p>
        <p>Tutorial: </p>
      `,
      primary: 'Start exploring',
      secondary: 'Replay',
      placement: 'center'
    }
  ];

  // ----- Minimal tour engine (no external deps) -----
  const lsKey = 'epigen_tour_completed_v1';
  const backdrop = document.getElementById('tour-backdrop');
  const spot = document.getElementById('tour-spotlight');
  const tip = document.getElementById('tour-tooltip');
  const helpBtn = document.getElementById('help-replay-tutorial');
  // Add a gentle pulse to the ? button until the tutorial has been completed once
if (helpBtn && localStorage.getItem(lsKey) !== '1') {
  helpBtn.classList.add('pulse');
}

  let idx = 0;
  let activeTargets = [];

  function show(el){ el.style.display = 'block'; }
  function hide(el){ el.style.display = 'none'; }
  function clearFocus(){
    activeTargets.forEach(t => t.classList.remove('tour-target-focus'));
    activeTargets = [];
    hide(spot);
  }

  function getFirstVisible(selectors){
    // supports comma-separated list; returns the first visible element
    const parts = selectors.split(',').map(s => s.trim());
    for (const p of parts){
      const el = document.querySelector(p);
      if (!el) continue;
      const rect = el.getBoundingClientRect();
      const visible = rect.width > 0 && rect.height > 0;
      if (visible) return el;
    }
    return null;
  }

  function positionTooltip(target, placement){
    const padding = 10;
    const tr = target.getBoundingClientRect();
    const tt = tip.getBoundingClientRect();

    let top = window.scrollY + tr.top;
    let left = window.scrollX + tr.left;

    if (placement === 'top'){
      top = window.scrollY + tr.top - tt.height - padding;
      left = window.scrollX + tr.left + (tr.width - tt.width)/2;
    } else if (placement === 'bottom'){
      top = window.scrollY + tr.bottom + padding;
      left = window.scrollX + tr.left + (tr.width - tt.width)/2;
    } else if (placement === 'left'){
      top = window.scrollY + tr.top + (tr.height - tt.height)/2;
      left = window.scrollX + tr.left - tt.width - padding;
    } else if (placement === 'right'){
      top = window.scrollY + tr.top + (tr.height - tt.height)/2;
      left = window.scrollX + tr.right + padding;
    } else { // center
      top = window.scrollY + (window.innerHeight - tt.height)/2;
      left = window.scrollX + (window.innerWidth - tt.width)/2;
    }

    // keep inside viewport
    top = Math.max(window.scrollY + 12, Math.min(top, window.scrollY + window.innerHeight - tt.height - 12));
    left = Math.max(window.scrollX + 12, Math.min(left, window.scrollX + window.innerWidth - tt.width - 12));

    tip.style.top = `${top}px`;
    tip.style.left = `${left}px`;
  }

  function spotlight(target){
    const r = target.getBoundingClientRect();
    spot.style.display = 'block';
    spot.style.top = `${window.scrollY + r.top - 8}px`;
    spot.style.left = `${window.scrollX + r.left - 8}px`;
    spot.style.width = `${r.width + 16}px`;
    spot.style.height = `${r.height + 16}px`;
  }

  function renderStep(i){
    clearFocus();
    if (i < 0 || i >= steps.length){
      endTour();
      promptForMapChoice();
      return;
    }
    idx = i;
    show(backdrop); // ensure the dimmed overlay appears for every step
    const s = steps[i];
    tip.innerHTML = `
      <h4>${s.title}</h4>
      ${s.html}
      <div class="tour-actions">
        ${s.allowSkip ? '<button class="link" data-act="skip">Skip for now</button>' : ''}
        ${s.secondary ? '<button data-act="secondary">'+s.secondary+'</button>' : ''}
        <button class="primary" data-act="primary">${s.primary || 'Next'}</button>
      </div>
    `;

    // Attach actions
    tip.querySelectorAll('[data-act]').forEach(btn => {
  btn.onclick = () => {
    const act = btn.getAttribute('data-act');
    if (act === 'primary') {
      if (s.id === 'goodbye') {
        endTour();
        promptForMapChoice();
      } else {
        renderStep(i + 1);
      }
    } else if (act === 'secondary') {
      // For goodbye: replay; otherwise go back
      if (s.id === 'goodbye') startTour(true);
      else renderStep(Math.max(0, i - 1));
    } else if (act === 'skip') {
      // Exit without marking complete, so it will show next time
      endTour();
      promptForMapChoice();
    }
  };
});

    show(backdrop);
    show(tip);
    if (s.selector) {
      hide(backdrop);      // donâ€™t tint the whole screen
      show(spot);
    } else {
      show(backdrop);      // only use the global dim when thereâ€™s no target
      hide(spot);
    }

    // If there is a target to highlight
    if (s.selector){
      const target = getFirstVisible(s.selector);
      if (target){
        target.scrollIntoView({behavior:'smooth', block:'center', inline:'center'});
        target.classList.add('tour-target-focus');
        activeTargets = [target];
        spotlight(target);
        show(spot);
        // Position tooltip around target
        tip.style.display = 'block'; // ensure size measured
        positionTooltip(target, s.placement || 'bottom');
      } else {
        // No visible target found â€” center the tooltip
        hide(spot);
        tip.style.display = 'block';
        positionTooltip(document.body, 'center');
      }
    } else {
      // No selector â€” center message
      hide(spot);
      tip.style.display = 'block';
      positionTooltip(document.body, 'center');
    }
  }

  function startTour(){
  // Always start step 0 and show the overlay
  show(backdrop);
  if (typeof helpBtn !== 'undefined' && helpBtn) {
  helpBtn.addEventListener('click', (e) => {
    e.preventDefault(); e.stopPropagation();
    startTour(); // no gating; always restarts
  });
}
  renderStep(0);
}

  function endTour(){
  hide(backdrop); hide(spot); hide(tip);
  clearFocus();
  // No localStorage writes; we want the tour every startup.
}

  // Close on ESC
  window.addEventListener('keydown', (e)=>{
    if (e.key === 'Escape'){ endTour(); }
  });
  // Reposition on resize/scroll
  window.addEventListener('resize', ()=>{ if (tip.style.display!=='none' && steps[idx]?.selector){
    const t = getFirstVisible(steps[idx].selector); if (t){ positionTooltip(t, steps[idx].placement||'bottom'); spotlight(t); }
  }});
  window.addEventListener('scroll', ()=>{ if (tip.style.display!=='none' && steps[idx]?.selector){
    const t = getFirstVisible(steps[idx].selector); if (t){ positionTooltip(t, steps[idx].placement||'bottom'); spotlight(t); }
  }}, {passive:true});

  // Hook up Help button
  if (helpBtn) helpBtn.addEventListener('click', ()=>{ renderStep(0); });

  // Auto-start for first-time users after page is fully ready
  window.addEventListener('load', ()=>{ startTour(true); });
})();
</script>
  </body>
</html>

